<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郭鹏真PattenKuo的博客</title>
  
  <subtitle>不务正业的文艺程序猿</subtitle>
  <link href="https://guopengzhen.com/atom.xml" rel="self"/>
  
  <link href="https://guopengzhen.com/"/>
  <updated>2021-03-21T09:14:28.821Z</updated>
  <id>https://guopengzhen.com/</id>
  
  <author>
    <name>郭鹏真PattenKuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何通过派安盈Payoneer香港银行账户开设Stripe信用卡收款渠道-跨境电商独立站卖家</title>
    <link href="https://guopengzhen.com/%E9%9A%8F%E7%AC%94/64558/"/>
    <id>https://guopengzhen.com/%E9%9A%8F%E7%AC%94/64558/</id>
    <published>2021-03-21T07:03:34.000Z</published>
    <updated>2021-03-21T09:14:28.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>   如何通过<a href="http://share.payoneer.com/nav/B-HS19AXIWgH03QdsR0xFDsH-tO316TMzqlIFs7nNbqq0iMdQVlN4AEPUCAffwGDy3PA5jdH4XcZnDz2Qkqt0Q2">派安盈Payoneer</a>香港银行账户开设Stripe信用卡收款渠道？当然，我们做独立站，可以采用Paypal收款，也可以采用国内的<a href="https://www.oceanpayment.com/">钱海</a>、<a href="http://www.asiabill.com/">AsiaBill</a>之类的信用卡收款渠道，但是Stripe收款的渠道会更多一点，本土居民的接受度也更高一点。</p><p><img src="/%E9%9A%8F%E7%AC%94/64558/Stripe-Payment-Accept-Payments-Method.png" alt="Stripe接受的支付方式"></p><p>   当然，网上有各种野路子，要么是虚假资质，要么是虚假信息，但是对于我们想要长期好好做独立站的人而言，或许通过正规渠道开通收款，才是长久之计。</p><h1 id="需要准备的材料"><a class="markdownIt-Anchor" href="#需要准备的材料"></a> 需要准备的材料</h1><ul><li>派安盈Payoneer香港收款账户（<strong>必需项</strong>）</li><li>香港手机号码（<strong>必需项</strong>）</li><li>个人护照Passport（<strong>内地身份证是否可行，我没做测试，读者可以自行去测试</strong>）</li></ul><h1 id="为什么是派安盈payoneer香港收款账户"><a class="markdownIt-Anchor" href="#为什么是派安盈payoneer香港收款账户"></a> 为什么是派安盈Payoneer香港收款账户？</h1><p>   你如果已经有了合法合规的香港区域的银行收款账户，可以忽略这一部分。如果没有，继续向下看。<br>   我们去年Shopify Payments被限制使用以后，尝试使用了蚂蚁金服旗下的 <a href="https://www.worldfirst.com/">WorldFirst</a> 香港账户申请Stripe，但是下来之后，不到一天就被限制使用了，当时没有深入调查。今天在注册美国公司的时候，想想要不然再试试注册一下Stripe账户，后面通过了，查了查原因，得到如下的结论——</p><blockquote><p>WorldFirst 所签发的花旗银行账户是一个总账户，我们所有用户的账号持有人姓名为同一名称，实际拥有的只是一个子账号。用户之间仅由账户号进行区分，缺少账户独立性特征，无法正常绑定Stripe。但派安盈Payoneer签发的是一个独立的星展银行账户，每一个用户都是独立的，所以可以正常绑定Stripe。</p></blockquote><h1 id="通过payoneer申请注册stripe三步走"><a class="markdownIt-Anchor" href="#通过payoneer申请注册stripe三步走"></a> 通过Payoneer申请注册Stripe三步走</h1><p>   注册一个Payoneer账户<br>   如果你已经有了 Payoneer 账户，可以忽略这部分，如果没有，继续向下看。<br>   <a href="http://share.payoneer.com/nav/B-HS19AXIWgH03QdsR0xFDsH-tO316TMzqlIFs7nNbqq0iMdQVlN4AEPUCAffwGDy3PA5jdH4XcZnDz2Qkqt0Q2">派安盈Payoneer</a>注册账户没有任何门槛，无论是公司还是个人资质，都可以在 <a href="http://share.payoneer.com/nav/B-HS19AXIWgH03QdsR0xFDsH-tO316TMzqlIFs7nNbqq0iMdQVlN4AEPUCAffwGDy3PA5jdH4XcZnDz2Qkqt0Q2">派安盈Payoneer</a> 注册账号。但是我个人建议以公司的名义注册，不要和个人绑定的太死，比如员工离职了怎么办？合伙人散伙了怎么办？<strong>注意一下</strong>——</p><blockquote><p>以下是我的<a href="http://share.payoneer.com/nav/B-HS19AXIWgH03QdsR0xFDsH-tO316TMzqlIFs7nNbqq0iMdQVlN4AEPUCAffwGDy3PA5jdH4XcZnDz2Qkqt0Q2">派安盈Payoneer</a> Affiliate推广链接，通过这个链接注册Payoneer账户，当你收到1000美元后，咱俩将额外分别获得25美元奖励。<strong>原创不易，感谢支持</strong> 。</p></blockquote><h2 id="向payoneer客服申请签发香港银行账户"><a class="markdownIt-Anchor" href="#向payoneer客服申请签发香港银行账户"></a> 向Payoneer客服申请签发香港银行账户</h2><p>   直接在网站上找<a href="https://payoneer-zh.custhelp.com/app/home">在线客服</a>，或者去打电话，微信上的公众号<strong>PayoneerPlus</strong>【微信号：PayoneerPlus 】和他们直接联系就好。</p><h1 id="申请一个香港的电话号码"><a class="markdownIt-Anchor" href="#申请一个香港的电话号码"></a> 申请一个香港的电话号码</h1><p>   香港号码主要有以下三个途径——</p><h2 id="找一个香港朋友帮忙接收验证码免费"><a class="markdownIt-Anchor" href="#找一个香港朋友帮忙接收验证码免费"></a> 找一个香港朋友帮忙接收验证码（免费）</h2><p>   如果你有在香港的朋友，直接让他们帮你接收一个验证码就可以了。没有的话，就看下面两种方法。</p><h2 id="淘宝购买一张香港实体手机sim卡20左右"><a class="markdownIt-Anchor" href="#淘宝购买一张香港实体手机sim卡20左右"></a> 淘宝购买一张香港实体手机SIM卡（￥20左右）</h2><p>   这时候可以向万能的淘宝求救，如下图所示。实体卡会有一个问题，邮寄过来，需要几天的时间，看你的个人需求，是不是必须要一张实体卡。</p><p><img src="/%E9%9A%8F%E7%AC%94/64558/%E9%A6%99%E6%B8%AF%E6%89%8B%E6%9C%BA%E5%8D%A1.png" alt="淘宝购买一张香港实体手机SIM卡"></p><h2 id="中国移动无忧行购买一张香港虚拟手机sim卡6左右"><a class="markdownIt-Anchor" href="#中国移动无忧行购买一张香港虚拟手机sim卡6左右"></a> 中国移动无忧行购买一张香港虚拟手机SIM卡（￥6左右）</h2><p>   这个方法是我们所建议的，因为并不是真的需要一张实体卡，只要能接收验证码就可以，所以如果你有中国移动的手机号（<strong>跨境卖家或许必须备一个中国移动的手机号，比如还可以申请和多号</strong>），可以下载一个中国移动旗下的【<a href="https://www.jegotrip.com/wyx/web/index.html">无忧行APP</a>】，按照下面动图的操作步骤，只需要花费6元人民币就可以获得一个香港手机号七天的使用权。</p><p><img src="/%E9%9A%8F%E7%AC%94/64558/%E6%97%A0%E5%BF%A7%E8%A1%8Capp.gif" alt="淘宝购买一张香港实体手机SIM卡"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;   如何通过&lt;a href=&quot;http://share.payoneer.com/nav/B-HS19AXIWgH03QdsR0xFDsH-t</summary>
      
    
    
    
    <category term="随笔" scheme="https://guopengzhen.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="工具" scheme="https://guopengzhen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="跨境电商" scheme="https://guopengzhen.com/tags/%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>#青春万岁，追梦无罪#迟到的318川藏线Part18玉曲河：雪融玉曲走怒江，两岸青稞忆盛唐</title>
    <link href="https://guopengzhen.com/%E9%9A%8F%E7%AC%94/8198/"/>
    <id>https://guopengzhen.com/%E9%9A%8F%E7%AC%94/8198/</id>
    <published>2021-03-06T10:15:30.000Z</published>
    <updated>2021-03-16T06:59:38.091Z</updated>
    
    <content type="html"><![CDATA[<p><strong>知我罪我，一任诸公。</strong></p><blockquote><p>之前，我们在上班下班的每一天，重复着昨日的路线<br>今天，我们在翻山越岭的路上，似乎仍看不到尽头<br>——题记</p></blockquote><p><img src="/%E9%9A%8F%E7%AC%94/8198/Day14map.png" alt="左贡到邦达"><br>Day14行程</p><p>  <a href="https://guopengzhen.com/%E9%9A%8F%E7%AC%94/57391/">前文</a>写道，我们从海拔5130m的东达山一路37km的长下坡，期间雨水变成了冰雹，视频为证。</p><video width="270" height="480" controls>  <source src="青春万岁，追梦无罪-迟到的318川藏线Part18玉曲河：雪融玉曲走怒江，两岸青稞忆盛唐/东达山冰雹.mp4" type="video/mp4"></video><p>   我算是后面到达左贡的，运动员一行已经找好了落脚的旅社，顺着他们发的定位就赶过去了。在门口，遇到了一个老伯，我问，<br>   “最近，这边最近游客多吗？”<br>   “多什么！唉，少的不得了。前几天下雨，泥石流，把那边路给堵住了，几天还没抢修通。”<br>   “啊！又是泥石流，我们过来的这条路上没看到啊！”<br>  “不是你们来的这条，是那一条…”他说着跟我指了指方向。<br>  和这个老伯告别后，我顺着他们群里发来的客栈的定位，就直接过去了。</p><p>  到了客栈门口，发现这是一个大院子，所谓的客房，不过是四周又充当了院墙的小房子，之所以会有一个大院子，一般是提供给跑长途运输的司机的。类似这种住处，我小学的时候跟老爸一起跑车，在格尔木住过，对，是这种熟悉的感觉。即使这几十年，我国经历了快速的经济发展期，但有些地方，或许只是另外一些地方十几年前的样子。<br>  为了洗衣服，等了一个多小时，还是那种机井打出来的凉水；为了洗个澡，排队排了半个小时，进了钢板房的洗澡间，需要换的衣服却无处安放。<br>  收拾妥当后，四川的骑友小龙建议，“好不容易到了一个县城，去吃个火锅吧！”<br>  大家最近几天的伙食着实需要改善，一致同意了这个家伙的建议，一起出发了。从客栈的另一个小门出去，路过一个几十米的菜市场街道，到了他建议的火锅店。<br>  我们的包间名叫做“冈仁波齐”，“冈”藏语发音为“扛”，意义为“雪”，“仁波齐”即“仁波切”的另一音译，意为珍宝，总称意为“雪宝”。在梵文中意为“湿婆的天堂”（湿婆为印度教主神）。</p><blockquote><p>藏传佛教认为，此山是胜乐金刚的住所，代表着无量幸福，也是莲花生大士战胜苯教徒的地方。耆那教认为该山是其祖师瑞斯哈巴那刹的得道处所。而印度教认为该山为湿婆的寓所，是世界的中心。相传苯教也发源于该处。因此，出于虔诚信仰和祈福灭罪的目的，上述各种宗教都有不少信徒不辞艰辛，从四面八方跋山涉水来到在此处朝圣、转山。以致冈仁波齐峰常年朝圣者络绎不绝，成为名副其实的“多重”宗教圣地。鉴于佛教、耆那教、印度教、苯教信徒共同崇拜这座圣山，其本身自古至今的神秘莫测及在人们心中神圣不可侵犯的精神价值，致使这座山峰至今保持着无人攀登、没被污染的纯洁无瑕风貌。</p></blockquote><p><img src="/%E9%9A%8F%E7%AC%94/8198/%E5%86%88%E4%BB%81%E6%B3%A2%E9%BD%90.jpg" alt="冈仁波齐"><br>   考虑到有一个耐受不来重口味的广东骑友何队，我们就点了一个鸳鸯锅，而且清淡不辣的那一面，特意对向了他。<br><img src="/%E9%9A%8F%E7%AC%94/8198/%E5%B7%A6%E8%B4%A1%E5%A4%A7%E9%85%92%E5%BA%97.jpg" alt="左贡大酒店"></p><p>   吃饱喝足，满意地在左贡的“步行街”逛一逛。意外地发现了一个河南老乡，卖烧饼和包子的，询问了他们明早开始营业的时间，满意地回客房睡下了。</p><h2 id="day14-左贡k3592h3750田妥镇k3632h3906邦达k3695h4300-行程107km"><a class="markdownIt-Anchor" href="#day14-左贡k3592h3750田妥镇k3632h3906邦达k3695h4300-行程107km"></a> DAY14: 左贡（K3592，H3750）——田妥镇（K3632，H3906）——邦达（K3695，H4300） 行程107KM</h2><p><img src="/%E9%9A%8F%E7%AC%94/8198/%E5%B7%A6%E8%B4%A1%E5%88%B0%E9%82%A6%E8%BE%BE.png" alt="左贡到邦达"></p><p>   先是42km起伏路到田妥镇，再22km起伏路到田妥村，然后17km平路，最后26km起伏路就到邦达了。<br>   今天的路程比较简单，几乎可以算作是平路了，没有什么压力。所以大家早上八点多才起床，我和风光先去了昨天那家烧饼店，结果还没开门，于是我们先去了斜对面不远处的一家小笼包早餐店吃了点东西。等到那家老板开门，已经是<br>9点多了，晃晃悠悠，一人屯了几个大饼，就出发了…<br>   两个队伍从在雅安初会，相克宗同时休息吹大山，巴塘合伙搭车，到现在几乎是准备后续的路一起骑完了。<br>   在路上，一会你超过我，一会我超过你，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;知我罪我，一任诸公。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前，我们在上班下班的每一天，重复着昨日的路线&lt;br&gt;
今天，我们在翻山越岭的路上，似乎仍看不到尽头&lt;br&gt;
——题记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src</summary>
      
    
    
    
    <category term="随笔" scheme="https://guopengzhen.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="随笔" scheme="https://guopengzhen.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="318" scheme="https://guopengzhen.com/tags/318/"/>
    
    <category term="游记" scheme="https://guopengzhen.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Interpreter 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/</id>
    <published>2021-02-08T08:21:45.000Z</published>
    <updated>2021-02-13T09:40:57.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="interpreter-模式简介"><a class="markdownIt-Anchor" href="#interpreter-模式简介"></a> Interpreter 模式简介：</h2><p>   解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。比如一些重复出现的问题可以用一种简单的语言来进行表达。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>   一些应用提供了内建（Build-In）的脚本或者宏语言来让用户可以定义他们能够在系统中进行的操作。Interpreter模式的目的就是使用一个解释器为用户提供一个一门定义语言的语法表示的解释器，然后通过这个解释器来解释语言中的句子。<br>     Interpreter模式提供了这样的一个实现语法解释器的框架。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   解释器模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/Interpreter.png" alt="Interpreter Pattern"><br>图 1:Interpreter 模式结构示意图</p><p>   Interpreter模式中，提供了<code>TerminalExpression</code>和<code>NonterminalExpression</code>两种表达式的解释方式，<code>Context</code>类用于为解释过程提供一些附加的信息（例如全局的信息）。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>   Interpreter模式的实现比较简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Interpreter">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Interpreter&gt; tree &#x2F;F </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Context.h</span><br><span class="line">│      Interpret.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Context.cpp</span><br><span class="line">        Interpret.cpp</span><br><span class="line">        main.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Interpreter&gt;</span><br></pre></td></tr></table></figure><p>Context.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context.h</span><br><span class="line"></span><br><span class="line">#ifndef _CONTEXT_H_</span><br><span class="line">#define _CONTEXT_H_</span><br><span class="line"></span><br><span class="line">class Context &#123;</span><br><span class="line"> public:</span><br><span class="line">  Context();</span><br><span class="line">  ~Context();</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line"> private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_CONTEXT_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Interpret.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Interpret.h</span><br><span class="line"></span><br><span class="line">#ifndef _INTERPRET_H_</span><br><span class="line">#define _INTERPRET_H_</span><br><span class="line"></span><br><span class="line">#include &quot;Context.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AbstractExpression&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual ~AbstractExpression();</span><br><span class="line">    virtual void Interpret(const Context&amp; c);</span><br><span class="line">    protected:</span><br><span class="line">    AbstractExpression();</span><br><span class="line">    private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TerminalExpression:public AbstractExpression&#123;</span><br><span class="line">    public:</span><br><span class="line">    TerminalExpression(const string&amp; statement);</span><br><span class="line">    ~ TerminalExpression();</span><br><span class="line">    void Interpret(const Context&amp; c);</span><br><span class="line">    protected:</span><br><span class="line">    private:</span><br><span class="line">    string _statement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class NonterminalExpression:public AbstractExpression&#123;</span><br><span class="line">    public:</span><br><span class="line">    NonterminalExpression(AbstractExpression* expression,int times);</span><br><span class="line">    ~ NonterminalExpression();</span><br><span class="line">    void Interpret(const Context&amp; c);</span><br><span class="line">    protected:</span><br><span class="line">    private:</span><br><span class="line">    AbstractExpression* _expression;</span><br><span class="line">    int _times;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_INTERPRET_H_</span><br></pre></td></tr></table></figure><p>Context.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line"></span><br><span class="line">Context::Context() &#123;&#125;</span><br><span class="line">Context::~Context() &#123;&#125;</span><br></pre></td></tr></table></figure><p>Interpret.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Interpret.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Interpret.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">AbstractExpression::AbstractExpression() &#123;&#125;</span><br><span class="line">AbstractExpression::~AbstractExpression() &#123;&#125;</span><br><span class="line">void AbstractExpression::Interpret(const Context&amp; c) &#123;&#125;</span><br><span class="line">TerminalExpression::TerminalExpression(const string&amp; statement) &#123; this-&gt;_statement &#x3D; statement; &#125;</span><br><span class="line">TerminalExpression::~TerminalExpression() &#123;&#125;</span><br><span class="line">void TerminalExpression::Interpret(const Context&amp; c) &#123;</span><br><span class="line">  cout &lt;&lt; this-&gt;_statement &lt;&lt; &quot; TerminalExpression&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">NonterminalExpression::NonterminalExpression(AbstractExpression* expression, int times) &#123;</span><br><span class="line">  this-&gt;_expression &#x3D; expression;</span><br><span class="line">  this-&gt;_times &#x3D; times;</span><br><span class="line">&#125;</span><br><span class="line">NonterminalExpression::~NonterminalExpression() &#123;&#125;</span><br><span class="line">void NonterminalExpression::Interpret(const Context&amp; c) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; _times; i++) &#123;</span><br><span class="line">    this-&gt;_expression-&gt;Interpret(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Interpret.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Context* c &#x3D; new Context();</span><br><span class="line">  AbstractExpression* te &#x3D; new TerminalExpression(&quot;hello&quot;);</span><br><span class="line">  AbstractExpression* nte &#x3D; new NonterminalExpression(te, 2);</span><br><span class="line">  nte-&gt;Interpret(*c);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>    Interpreter模式的示例代码很简单，只是为了说明模式的组织和使用，实际的解释Interpret逻辑没有实际提供。</p><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   XML格式的数据解析是一个在应用开发中很常见并且有时候是很难处理的事情，虽然目前很多的开发平台、语言都提供了对XML格式数据的解析，但是例如到了移动终端设备上，由于处理速度、计算能力、存储容量的原因解析XML格式的数据却是很复杂的一件事情，最近也提出了很多的移动设备的XML格式解析器，但是总体上在项目开发时候还是需要自己去设计和实现这一个过程（笔者就有过这个方面的痛苦经历）。<br>  Interpreter模式则提供了一种很好的组织和设计这种解析器的架构。<br>  Interpreter模式中使用类来表示文法规则，因此可以很容易实现文法的扩展。另外对于终结符我们可以使用<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight模式</a>来实现终结符的共享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Iterator 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/</id>
    <published>2021-02-08T08:04:47.000Z</published>
    <updated>2021-02-13T09:40:49.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="iterator-模式简介"><a class="markdownIt-Anchor" href="#iterator-模式简介"></a> Iterator 模式简介：</h2><p>   迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。从而访问一个聚合对象的内容而无须暴露它的内部表示。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>   迭代器模式应该是最为熟悉的模式了，最简单的证明就是我在实现<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite模式</a>、<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight模式</a>、<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer模式</a>中就直接用到了STL提供的Iterator来遍历Vector或者List数据结构。<br>     Iterator模式也正是用来解决对一个聚合对象的遍历问题，将对聚合的遍历封装到一个类中进行，这样就避免了暴露这个聚合对象的内部表示的可能。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>     Iterator模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/Iterator.png" alt="Iterator Pattern"><br>图 1:Iterator 模式结构示意图</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>     Iterator模式的实现比较简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Iterator">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Iterator&gt; tree &#x2F;F    </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Aggregate.h</span><br><span class="line">│      Iterator.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Aggregate.cpp</span><br><span class="line">        Iterator.cpp</span><br><span class="line">        main.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Iterator&gt;</span><br></pre></td></tr></table></figure><p>Aggregate.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Aggregate.h</span><br><span class="line"></span><br><span class="line">#ifndef _AGGREGATE_H_</span><br><span class="line">#define _AGGREGATE_H_</span><br><span class="line"></span><br><span class="line">class Iterator;</span><br><span class="line">typedef int Object;</span><br><span class="line"></span><br><span class="line">class Aggregate &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Aggregate(&#x2F;* args *&#x2F;);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Aggregate();</span><br><span class="line">  virtual Iterator* CreateIterator() &#x3D; 0;</span><br><span class="line">  virtual Object GetItem(int idx) &#x3D; 0;</span><br><span class="line">  virtual int GetSize() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteAggregate : public Aggregate &#123;</span><br><span class="line"> public:</span><br><span class="line">  enum &#123; SIZE &#x3D; 3 &#125;;</span><br><span class="line">  ConcreteAggregate(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~ConcreteAggregate();</span><br><span class="line">  Iterator* CreateIterator();</span><br><span class="line">  Object GetItem(int idx);</span><br><span class="line">  int GetSize();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  Object _objs[SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_AGGREGATE_H_</span><br></pre></td></tr></table></figure><p>Iterator.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Iterator.h</span><br><span class="line"></span><br><span class="line">#ifndef _ITERATOR_H_</span><br><span class="line">#define _ITERATOR_H_</span><br><span class="line"></span><br><span class="line">class Aggregate;</span><br><span class="line"></span><br><span class="line">typedef int Object;</span><br><span class="line"></span><br><span class="line">class Iterator &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Iterator(&#x2F;* args *&#x2F;);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ~Iterator();</span><br><span class="line">  virtual void First() &#x3D; 0;</span><br><span class="line">  virtual void Next() &#x3D; 0;</span><br><span class="line">  virtual bool IsDone() &#x3D; 0;</span><br><span class="line">  virtual Object CurrentItem() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteIterator : public Iterator &#123;</span><br><span class="line"> private:</span><br><span class="line">  Aggregate* _ag;</span><br><span class="line">  int _idx;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteIterator(Aggregate* ag, int idx &#x3D; 0);</span><br><span class="line">  ~ConcreteIterator();</span><br><span class="line">  void First();</span><br><span class="line">  void Next();</span><br><span class="line">  bool IsDone();</span><br><span class="line">  Object CurrentItem();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_ITERATOR_H_</span><br></pre></td></tr></table></figure><p>Aggregate.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Aggregate.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Aggregate.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Iterator.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Aggregate::Aggregate(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Aggregate::~Aggregate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteAggregate::ConcreteAggregate(&#x2F;* args *&#x2F;) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; SIZE; i++) _objs[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">ConcreteAggregate::~ConcreteAggregate() &#123;&#125;</span><br><span class="line">Iterator* ConcreteAggregate::CreateIterator() &#123; return new ConcreteIterator(this); &#125;</span><br><span class="line">Object ConcreteAggregate::GetItem(int idx) &#123;</span><br><span class="line">  if (idx &lt; this-&gt;GetSize())</span><br><span class="line">    return _objs[idx];</span><br><span class="line">  else</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int ConcreteAggregate::GetSize()&#123;</span><br><span class="line">    return SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Iterator.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Iterator.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Iterator.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Aggregate.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Iterator::Iterator(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Iterator::~Iterator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteIterator::ConcreteIterator(Aggregate*ag , int idx) &#123;</span><br><span class="line">    this-&gt;_ag &#x3D; ag;</span><br><span class="line">    this-&gt;_idx &#x3D; idx;</span><br><span class="line">&#125;</span><br><span class="line">ConcreteIterator::~ConcreteIterator() &#123;&#125;</span><br><span class="line">Object ConcreteIterator::CurrentItem()&#123;</span><br><span class="line">    return _ag-&gt;GetItem(_idx);</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteIterator::First()&#123;</span><br><span class="line">    _idx &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteIterator::Next()&#123;</span><br><span class="line">    if (_idx &lt; _ag-&gt;GetSize()) _idx++;</span><br><span class="line">&#125;</span><br><span class="line">bool ConcreteIterator::IsDone()&#123;</span><br><span class="line">    return (_idx &#x3D;&#x3D; _ag-&gt;GetSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Iterator.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Aggregate.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Aggregate* ag &#x3D; new ConcreteAggregate();</span><br><span class="line">  Iterator* it &#x3D; new ConcreteIterator(ag);</span><br><span class="line">  for (; !(it-&gt;IsDone()); it-&gt;Next()) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;CurrentItem() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>   Iterator模式的实现代码很简单，实际上为了更好地保护<code>Aggregate</code>的状态，我们可以尽量减小<code>Aggregate</code>的<code>public</code>接口，而通过将<code>Iterator</code>对象声明位<code>Aggregate</code>的友元来给予<code>Iterator</code>一些特权，获得访问<code>Aggregate</code>私有数据和方法的机会。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Iterator\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Iterator\src&gt; .\a.exe</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Iterator\src&gt; </span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   Iterator模式的应用很常见，我们在开发中就经常会用到STL中预定义好的<code>Iterator</code>来对STL类进行遍历（<code>Vector</code>、<code>Set</code>等）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Chain of Responsibility 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/</id>
    <published>2021-02-08T07:09:42.000Z</published>
    <updated>2021-02-13T09:41:14.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="chain-of-responsibility-模式简介"><a class="markdownIt-Anchor" href="#chain-of-responsibility-模式简介"></a> Chain of Responsibility 模式简介：</h2><p>   顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>   在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。比如红楼梦中的&quot;击鼓传花&quot;。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>   熟悉VC/MFC的都知道，VC是“基于消息，事件驱动”，消息在VC开发中起着举足轻重的作用。在MFC中，消息是通过一个向上递交的方式进行处理，例如一个<code>WM_COMMAND</code>消息的处理流程可能为：</p><ul><li>MDI主窗口（<code>CMDIFrameWnd</code>）收到命令消息<code>WM_COMMAND</code>，其ID位<code>ID_×××</code>；</li><li>MDI主窗口将消息传给当前活动的MDI子窗口（<code>CMDIChildWnd</code>）；</li><li>MDI子窗口给自己的子窗口（<code>View</code>）一个处理机会，将消息交给<code>View</code>；</li><li><code>View</code>检查自己<code>Message Map</code>；</li><li>如果<code>View</code>没有发现处理该消息的程序，则将该消息传给其对应的<code>Document</code>对象；否则<code>View</code>处理，消息流程结束。</li><li><code>Document</code>检查自己<code>Message Map</code>，如果没有该消息的处理程序，则将该消息传给其对象的<code>DocumentTemplate</code>处理；否则自己处理，消息流程结束；</li><li>如果在上一步中消息没有得到处理，则将消息返回给<code>View</code>；</li><li><code>View</code>再传回给MDI子窗口；</li><li>MDI子窗口将该消息传给<code>CwinApp</code>对象，<code>CwinApp</code>为所有无主的消息提供了处理。</li></ul><blockquote><p>有关MFC消息处理更加详细信息，请参考候捷先生的《深入浅出MFC》。</p></blockquote><p>   MFC提供了消息的处理的链式处理策略，处理消息的请求将沿着预先定义好的路径依次进行处理。消息的发送者并不知道该消息最后是由那个具体对象处理的，当然它也无须也不想知道，但是结构是该消息被某个对象处理了，或者一直到一个终极的对象进行处理了。</p><p>   Chain of Responsibility模式描述其实就是这样一类问题将可能处理一个请求的对象链接成一个链，并将请求在这个链上传递，直到有对象处理该请求（可能需要提供一个默认处理所有请求的类，例如MFC中的<code>CwinApp</code>类）。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   Chain of Responsibility模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/Responsibility.png" alt="Chain of Responsibility"><br>图 1:Chain of Responsibility 模式结构示意图</p><p>   Chain of Responsibility模式中<code>ConcreteHandler</code>将自己的后继对象（向下传递消息的对象）记录在自己的后继表中，当一个请求到来时，<code>ConcreteHandler</code>会先检查看自己有没有匹配的处理程序，如果有就自己处理，否则传递给它的后继。当然这里示例程序中为了简化，<code>ConcreteHandler</code>只是简单的检查看自己有没有后继，有的话将请求传递给后继进行处理，没有的话就自己处理。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>   Chain of Responsibility模式的实现比较简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/ChainofResponsibility">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\ChainofResponsibility&gt; tree &#x2F;F</span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Handle.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Handle.cpp</span><br><span class="line">        main.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\ChainofResponsibility&gt;</span><br></pre></td></tr></table></figure><p>Handle.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Handle.h</span><br><span class="line"></span><br><span class="line">#ifndef _HANDLE_H_</span><br><span class="line">#define _HANDLE_H_</span><br><span class="line"></span><br><span class="line">class Handle &#123;</span><br><span class="line"> private:</span><br><span class="line">  Handle* _succ;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Handle(&#x2F;* args *&#x2F;);</span><br><span class="line">  Handle(Handle* succ);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Handle();</span><br><span class="line">  virtual void HandleRequest() &#x3D; 0;</span><br><span class="line">  void SetSuccessor(Handle* succ);</span><br><span class="line">  Handle* GetSuccessor();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteHandleA:public Handle</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    ConcreteHandleA(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~ConcreteHandleA();</span><br><span class="line">    ConcreteHandleA(Handle* succ);</span><br><span class="line">    void HandleRequest();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteHandleB:public Handle</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    ConcreteHandleB(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~ConcreteHandleB();</span><br><span class="line">    ConcreteHandleB(Handle* succ);</span><br><span class="line">    void HandleRequest();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_HANDLE_H_</span><br></pre></td></tr></table></figure><p>Handle.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Handle.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Handle.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Handle::Handle(&#x2F;* args *&#x2F;) &#123; _succ &#x3D; 0; &#125;</span><br><span class="line">Handle::Handle(Handle* succ) &#123; this-&gt;_succ &#x3D; succ; &#125;</span><br><span class="line">Handle::~Handle() &#123; delete _succ; &#125;</span><br><span class="line">void Handle::SetSuccessor(Handle* succ) &#123; _succ &#x3D; succ; &#125;</span><br><span class="line">Handle* Handle::GetSuccessor() &#123; return _succ; &#125;</span><br><span class="line">void Handle::HandleRequest() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteHandleA::ConcreteHandleA(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteHandleA::ConcreteHandleA(Handle* succ) : Handle(succ) &#123;&#125;</span><br><span class="line">ConcreteHandleA::~ConcreteHandleA() &#123;&#125;</span><br><span class="line">void ConcreteHandleA::HandleRequest() &#123;</span><br><span class="line">  if (this-&gt;GetSuccessor() !&#x3D; 0) &#123;</span><br><span class="line">    printf(&quot;ConcreteHandleA 我把处理权给后继节点..... \n&quot;);</span><br><span class="line">    this-&gt;GetSuccessor()-&gt;HandleRequest();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;ConcreteHandleA 没有后继了,我必须自己处理..... \n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteHandleB::ConcreteHandleB(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteHandleB::ConcreteHandleB(Handle* succ) : Handle(succ) &#123;&#125;</span><br><span class="line">ConcreteHandleB::~ConcreteHandleB() &#123;&#125;</span><br><span class="line">void ConcreteHandleB::HandleRequest() &#123;</span><br><span class="line">  if (this-&gt;GetSuccessor() !&#x3D; 0) &#123;</span><br><span class="line">    printf(&quot;ConcreteHandleB 我把处理权给后继节点..... \n&quot;);</span><br><span class="line">    this-&gt;GetSuccessor()-&gt;HandleRequest();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;ConcreteHandleB 没有后继了,我必须自己处理..... \n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Handle.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line">    Handle* h1 &#x3D; new ConcreteHandleA();</span><br><span class="line">    Handle* h2 &#x3D; new ConcreteHandleB();</span><br><span class="line">    h1-&gt;SetSuccessor(h2);</span><br><span class="line">    h1-&gt;HandleRequest();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>   Chain of Responsibility模式的示例代码实现很简单，这里就其测试结果给出说明：<code>ConcreteHandleA</code>的对象和<code>h1</code>拥有一个后继<code>ConcreteHandleB</code>的对象<code>h2</code>,当一个请求到来时候，<code>h1</code>检查看自己有后继，于是<code>h1</code>直接将请求传递给其后继<code>h2</code>进行处理，<code>h2</code>因为没有后继，当请求到来时候，就只有自己提供响应了。于是程序的输出为：</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">guopz@Patten-DESKTOP MINGW64 ~&#x2F;Desktop&#x2F;GiteeBlog&#x2F;designpatternsbycpipei&#x2F;behavioralPattern&#x2F;ChainofResponsibility&#x2F;src (master)</span><br><span class="line">$ g++ *.cpp -std&#x3D;c++11</span><br><span class="line"></span><br><span class="line">guopz@Patten-DESKTOP MINGW64 ~&#x2F;Desktop&#x2F;GiteeBlog&#x2F;designpatternsbycpipei&#x2F;behavioralPattern&#x2F;ChainofResponsibility&#x2F;src (master)</span><br><span class="line">$ .&#x2F;a.exe</span><br><span class="line">ConcreteHandleA 我把处理权给后继节点.....</span><br><span class="line">ConcreteHandleB 没有后继了,我必须自己处理.....</span><br><span class="line"></span><br><span class="line">guopz@Patten-DESKTOP MINGW64 ~&#x2F;Desktop&#x2F;GiteeBlog&#x2F;designpatternsbycpipei&#x2F;behavioralPattern&#x2F;ChainofResponsibility&#x2F;src (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   Chain of Responsibility模式的最大的一个点就是给系统降低了耦合性，请求的发送者完全不必知道该请求会被哪个应答对象处理，极大地降低了系统的耦合性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Visitor 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/</id>
    <published>2021-02-08T04:20:27.000Z</published>
    <updated>2021-02-13T09:40:23.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="visitor-模式简介"><a class="markdownIt-Anchor" href="#visitor-模式简介"></a> Visitor 模式简介：</h2><p>   在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br>   比如您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>   在面向对象系统的开发和设计过程，经常会遇到一种情况就是需求变更（RequirementChanging），经常我们做好的一个设计、实现了一个系统原型，咱们的客户又会有了新的需求。我们又因此不得不去修改已有的设计，最常见就是解决方案就是给已经设计、实现好的类添加新的方法去实现客户新的需求，这样就陷入了设计变更的梦魇：不停地打补丁，其带来的后果就是设计根本就不可能封闭、编译永远都是整个系统代码。<br>    Visitor模式则提供了一种解决方案：将更新（变更）封装到一个类中（访问操作），并由待更改类提供一个接收接口，则可达到效果。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   我们通过Visitor模式解决上面的问题，其典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/Visitor.png" alt="Visitor Pattern"><br>图 1:Observer 模式结构示意图</p><p>   Visitor模式在不破坏类的前提下，为类提供增加新的新操作。Visitor模式的关键是双分派（Double-Dispatch）的技术<sup>【注释1】</sup>。C++语言支持的是单分派。</p><blockquote><p>【注释1】：双分派意味着执行的操作将取决于请求的种类和接收者的类型。更多资料请参考资料。</p></blockquote><p>   在Visitor模式中<code>Accept（）</code>操作是一个双分派的操作。具体调用哪一个具体的<code>Accept（）</code>操作，有两个决定因素：</p><ul><li><code>Element</code>的类型。因为<code>Accept（）</code>是多态的操作，需要具体的<code>Element</code>类型的子类才可以决定到底调用哪一个<code>Accept（）</code>实现；</li><li><code>Visitor</code>的类型。<code>Accept（）</code>操作有一个参数（<code>Visitor* vis</code>），要决定了实际传进来的<code>Visitor</code>的实际类别才可以决定具体是调用哪个<code>VisitConcrete（）</code>实现。</li></ul><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>    Visitor模式的实现很简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Command">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Visitor&gt; tree &#x2F;F     </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Element.h</span><br><span class="line">│      Visitor.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Element.cpp</span><br><span class="line">        main.cpp</span><br><span class="line">        Visitor.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Visitor&gt;</span><br></pre></td></tr></table></figure><p>Element.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Element.h</span><br><span class="line"></span><br><span class="line">#ifndef _ELEMENT_H_</span><br><span class="line">#define _ELEMENT_H_</span><br><span class="line"></span><br><span class="line">class Visitor;</span><br><span class="line"></span><br><span class="line">class Element &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Element(&#x2F;* args *&#x2F;);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Element();</span><br><span class="line">  virtual void Accept(Visitor* vis) &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteElementA:public Element</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    ConcreteElementA(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~ConcreteElementA();</span><br><span class="line">    void Accept(Visitor* vis);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteElementB:public Element</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    ConcreteElementB(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~ConcreteElementB();</span><br><span class="line">    void Accept(Visitor* vis);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_ELEMENT_H_</span><br></pre></td></tr></table></figure><p>Visitor.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Visitor.h</span><br><span class="line"></span><br><span class="line">#ifndef _VISITOR_H_</span><br><span class="line">#define _VISITOR_H_</span><br><span class="line"></span><br><span class="line">class ConcreteElementA;</span><br><span class="line">class ConcreteElementB;</span><br><span class="line">class Element;</span><br><span class="line"></span><br><span class="line">class Visitor &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Visitor(&#x2F;* args *&#x2F;);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Visitor();</span><br><span class="line">  virtual void VisitConcreteElementA(Element* elm) &#x3D; 0;</span><br><span class="line">  virtual void VisitConcreteElementB(Element* elm) &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteVisitorA : public Visitor &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteVisitorA(&#x2F;* args *&#x2F;);</span><br><span class="line">  virtual ~ConcreteVisitorA();</span><br><span class="line">  virtual void VisitConcreteElementA(Element* elm);</span><br><span class="line">  virtual void VisitConcreteElementB(Element* elm);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteVisitorB : public Visitor &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"> public:</span><br><span class="line">  ConcreteVisitorB(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~ConcreteVisitorB();</span><br><span class="line">  virtual void VisitConcreteElementA(Element* elm);</span><br><span class="line">  virtual void VisitConcreteElementB(Element* elm);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_VISITOR_H_</span><br></pre></td></tr></table></figure><p>Element.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Element.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Element.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Visitor.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Element::Element(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Element::~Element() &#123;&#125;</span><br><span class="line">void Element::Accept(Visitor* vis) &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteElementA::ConcreteElementA(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteElementA::~ConcreteElementA() &#123;&#125;</span><br><span class="line">void ConcreteElementA::Accept(Visitor* vis) &#123;</span><br><span class="line">  vis-&gt;VisitConcreteElementA(this);</span><br><span class="line">  printf(&quot;visiting ConcreteElementA... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteElementB::ConcreteElementB(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteElementB::~ConcreteElementB() &#123;&#125;</span><br><span class="line">void ConcreteElementB::Accept(Visitor* vis) &#123;</span><br><span class="line">  vis-&gt;VisitConcreteElementA(this);</span><br><span class="line">  printf(&quot;visiting ConcreteElementA... \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Visitor.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Visitor.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Visitor.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Element.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Visitor::Visitor(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Visitor::~Visitor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteVisitorA::ConcreteVisitorA(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteVisitorA::~ConcreteVisitorA() &#123;&#125;</span><br><span class="line">void ConcreteVisitorA::VisitConcreteElementA(Element* elm) &#123;</span><br><span class="line">  printf(&quot;I will visit ConcreteElementA... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteVisitorA::VisitConcreteElementB(Element* elm) &#123;</span><br><span class="line">  printf(&quot;I will visit ConcreteElementB... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteVisitorB::ConcreteVisitorB(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteVisitorB::~ConcreteVisitorB() &#123;&#125;</span><br><span class="line">void ConcreteVisitorB::VisitConcreteElementA(Element* elm) &#123;</span><br><span class="line">  printf(&quot;I will visit ConcreteElementA... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteVisitorB::VisitConcreteElementB(Element* elm) &#123;</span><br><span class="line">  printf(&quot;I will visit ConcreteElementB... \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Element.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Visitor.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Visitor* vis &#x3D; new ConcreteVisitorA();</span><br><span class="line">  Element* elm &#x3D; new ConcreteElementA();</span><br><span class="line">  elm-&gt;Accept(vis);</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>   Visitor模式的实现过程中有以下的地方要注意：</p><ul><li><code>Visitor</code>类中的<code>Visit（）</code>操作的实现。<ul><li>这里我们可以向<code>Element</code>类仅仅提供一个接口<code>Visit（）</code>，而在<code>Accept（）</code>实现中具体调用哪一个<code>Visit（）</code>操作则通过函数重载（overload）的方式实现：我们提供<code>Visit（）</code>的两个重载版本<ul><li><code>Visit</code>（<code>ConcreteElementA* elmA</code>）;</li><li><code>Visit</code>（<code>ConcreteElementB* elmB</code>）。</li></ul></li><li>在C++中我们还可以通过RTTI（运行时类型识别：Runtime type identification）来实现，即我们只提供一个<code>Visit（）</code>函数体，传入的参数为<code>Element*</code>型别参数，然后用<code>RTTI</code>决定具体是哪一类的<code>ConcreteElement</code>参数，再决定具体要对哪个具体类施加什么样的具体操作。RTTI给接口带来了简单一致性，但是付出的代价是时间（RTTI的实现）和代码的Hard编码（要进行强制转换）。</li></ul></li></ul><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Visitor\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Visitor\src&gt; .\a.exe </span><br><span class="line">I will visit ConcreteElementA... </span><br><span class="line">visiting ConcreteElementA...</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Visitor\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   有时候我们需要为Element提供更多的修改，这样我们就可以通过为Element提供一系列的 Visitor模式可以使得Element在不修改自己的同时增加新的操作，但是这也带来了至少以下的两个显著问题：</p><ul><li>破坏了封装性。Visitor模式要求<code>Visitor</code>可以从外部修改<code>Element</code>对象的状态，这一般通过两个方式来实现：<ul><li><code>Element</code>提供足够的<code>public</code>接口，使得<code>Visitor</code>可以通过调用这些接口达到修改<code>Element</code>状态的目的；</li><li><code>Element</code>暴露更多的细节给<code>Visitor</code>，或者让<code>Element</code>提供<code>public</code>的实现给<code>Visitor</code>（当然也给了系统中其他的对象），或 者将<code>Visitor</code>声明为<code>Element</code>的<code>friend</code>类，仅将细节暴露给<code>Visitor</code>。但是无论那种情况，特别是后者都将是破坏了封装性原则（实际上就是C++的<code>friend</code>机制得到了很多的面向对象专家的诟病）</li></ul></li><li><code>ConcreteElement</code>的扩展很困难：每增加一个<code>Element</code>的子类，就要修改<code>Visitor</code>的接口，使得可以提供给这个新增加的子类的访问机制。从上面我们可以看到，或者增加一个用于处理新增类的<code>Visit（）</code>接口，或者重载一个处理新增类的<code>Visit（）</code>操作，或者要修改RTTI方式实现的<code>Visit（）</code>实现。无论那种方式都给扩展新的<code>Element</code>子类带来了困难。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Command 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/</id>
    <published>2021-02-08T03:44:42.000Z</published>
    <updated>2021-02-08T08:49:51.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="command-模式简介"><a class="markdownIt-Anchor" href="#command-模式简介"></a> Command 模式简介：</h2><p>   命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br>   在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>    Command模式通过将请求封装到一个对象（<code>Command</code>）中，并将请求的接受者存放到具体的<code>ConcreteCommand</code>类中（<code>Receiver</code>）中，从而实现调用操作的对象和操作的具体实现者之间的解耦。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   Command模式的典型结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/Command.png" alt="Command Pattern"><br>图 1:Command 模式结构示意图</p><p>   Command模式结构图中，将请求的接收者（处理者）放到<code>Command</code>的具体子类<code>ConcreteCommand</code>中，当请求到来时（<code>Invoker</code>发出<code>Invoke</code>消息激活<code>Command</code>对象），<code>ConcreteCommand</code>将处理请求交给<code>Receiver</code>对象进行处理。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>Command模式的实现很简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Command">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Command&gt; tree &#x2F;F     </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Command.h</span><br><span class="line">│      Concrete.h</span><br><span class="line">│      Invoker.h</span><br><span class="line">│      Receiver.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Command.cpp</span><br><span class="line">        Concrete.cpp</span><br><span class="line">        Invoker.cpp</span><br><span class="line">        main.cpp</span><br><span class="line">        Reciever.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Command&gt;</span><br></pre></td></tr></table></figure><p>Command.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Command.h</span><br><span class="line"></span><br><span class="line">#ifndef _COMMAND_H_</span><br><span class="line">#define _COMMAND_H_</span><br><span class="line"></span><br><span class="line">#include &quot;Receiver.h&quot;</span><br><span class="line"></span><br><span class="line">class Command</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Command();</span><br><span class="line">    virtual ~Command();</span><br><span class="line">    virtual void execute() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;_COMMAND_H_</span><br></pre></td></tr></table></figure><p>Concrete.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Concrete.h</span><br><span class="line"></span><br><span class="line">#ifndef _CONCRETE_H_</span><br><span class="line">#define _CONCRETE_H_</span><br><span class="line"></span><br><span class="line">#include &quot;Command.h&quot;</span><br><span class="line">#include &quot;Receiver.h&quot;</span><br><span class="line"></span><br><span class="line">class ConcreteCommand : public Command &#123;</span><br><span class="line"> public:</span><br><span class="line">  ConcreteCommand(Receiver *pReceiver);</span><br><span class="line">  virtual ~ConcreteCommand();</span><br><span class="line">  virtual void execute();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  Receiver *m_pReceiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;_CONCRETE_H_</span><br></pre></td></tr></table></figure><p>Invoker.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Invoker.h</span><br><span class="line"></span><br><span class="line">#ifndef _INVOKER_H_</span><br><span class="line">#define _INVOKER_H_</span><br><span class="line"></span><br><span class="line">#include &quot;Command.h&quot;</span><br><span class="line"></span><br><span class="line">class Invoker &#123;</span><br><span class="line"> public:</span><br><span class="line">  Invoker(Command *pCommand);</span><br><span class="line">  virtual ~Invoker();</span><br><span class="line">  void call();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  Command *m_pCommand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;_INVOKER_H_</span><br></pre></td></tr></table></figure><p>Receiver.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Receiver.h</span><br><span class="line"></span><br><span class="line">#ifndef _RECEIEVER_H_</span><br><span class="line">#define _RECEIEVER_H_</span><br><span class="line"></span><br><span class="line">class Receiver</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Receiver();</span><br><span class="line">    virtual ~Receiver();</span><br><span class="line"></span><br><span class="line">    void action();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_RECEIEVER_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Command.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Command.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Command.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">Command::Command()&#123;&#125;;</span><br><span class="line">Command::~Command()&#123;&#125;;</span><br></pre></td></tr></table></figure><p>Concrete.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Concrete.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Concrete.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ConcreteCommand::ConcreteCommand(Receiver *pReceiver) &#123; m_pReceiver &#x3D; pReceiver; &#125;</span><br><span class="line">ConcreteCommand::~ConcreteCommand() &#123;&#125;</span><br><span class="line">void ConcreteCommand::execute() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;ConcreteCommand::execute&quot; &lt;&lt; endl;</span><br><span class="line">  m_pReceiver-&gt;action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Invoker.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Invoker.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Invoker::Invoker(Command* pCommand) &#123; m_pCommand &#x3D; pCommand; &#125;</span><br><span class="line"></span><br><span class="line">Invoker::~Invoker() &#123;&#125;</span><br><span class="line"></span><br><span class="line">void Invoker::call() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;invoker calling&quot; &lt;&lt; endl;</span><br><span class="line">  m_pCommand-&gt;execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reciever.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Receiver.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Receiver.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">Receiver::Receiver(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Receiver::~Receiver() &#123;&#125;</span><br><span class="line">void Receiver::action()&#123;</span><br><span class="line">    printf(&quot;Receiver::Action...... \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Command.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Concrete.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Invoker.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Receiver.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  Receiver *pReceiver &#x3D; new Receiver();</span><br><span class="line">  ConcreteCommand *pCommand &#x3D; new ConcreteCommand(pReceiver);</span><br><span class="line">  Invoker *pInvoker &#x3D; new Invoker(pCommand);</span><br><span class="line">  pInvoker-&gt;call();</span><br><span class="line"></span><br><span class="line">  if (NULL !&#x3D; pReceiver) delete pReceiver;</span><br><span class="line">  if (NULL !&#x3D; pCommand) delete pCommand;</span><br><span class="line">  if (NULL !&#x3D; pInvoker) delete pInvoker;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>   Command模式在实现的实现和思想都很简单，其关键就是将一个请求封装到一个类中（<code>Command</code>），再提供处理对象（<code>Receiver</code>），最后<code>Command</code>命令由<code>Invoker</code>激活。另外，我们可以将请求接收者的处理抽象出来作为参数传给<code>Command</code>对象，实际也就是回调的机制（<code>Callback</code>）来实现这一点，也就是说将处理操作方法地址（在对象内部）通过参数传递给<code>Command</code>对象，<code>Command</code>对象在适当的时候（<code>Invoke</code>激活的时候）再调用该函数。这里就要用到C++中的类成员函数指针的概念。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Command\src&gt; .\a.exe </span><br><span class="line">invoker calling</span><br><span class="line">ConcreteCommand::execute</span><br><span class="line">Receiver::Action......</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Command\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>    Command模式的思想非常简单，但是Command模式也十分常见，并且威力不小。实际上，Command模式关键就是提供一个抽象的<code>Command</code>类，并将执行操作封装到<code>Command</code>类接口中，<code>Command</code>类中一般就是只是一些接口的集合，并不包含任何的数据属性（当然在示例代码中，我们的<code>Command</code>类有一个处理操作的<code>Receiver</code>类的引用，但是其作用也仅仅就是为了实现这个<code>Command</code>的<code>Excute</code>接口）。这种方式在是纯正的面向对象设计者最为鄙视的设计方式，就像OO设计新手做系统设计的时候，仅仅将<code>Class</code>作为一个关键字，将C种的全局函数找一个类封装起来就以为是完成了面向对象的设计。<br>    但是世界上的事情不是绝对的，上面提到的方式在OO设计种绝大部分的时候可能是一个不成熟的体现，但是在Command模式中却是起到了很好的效果。主要体现在：</p><ul><li>Command模式将调用操作的对象和知道如何实现该操作的对象解耦。在上面Command的结构图中，<code>Invoker</code>对象根本就不知道具体的是那个对象在处理<code>Excute</code>操作（当然要知道是<code>Command</code>类别的对象，也仅此而已）。</li><li>在<code>Command</code>要增加新的处理操作对象很容易，我们可以通过创建新的继承自<code>Command</code>的子类来实现这一点。</li><li>Command模式可以和<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento模式</a>结合起来，支持取消的操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;创建型模式creating-pattern&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建型模式creating-pattern&quot;&gt;&lt;/a&gt; 创建型模式(Creating Pattern)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Mediator 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/</id>
    <published>2021-02-08T03:21:03.000Z</published>
    <updated>2021-02-13T09:40:09.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="mediator-模式简介"><a class="markdownIt-Anchor" href="#mediator-模式简介"></a> Mediator 模式简介：</h2><p>   中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。比如中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>   在面向对象系统的设计和开发过程中，对象之间的交互和通信是最为常见的情况，因为对象间的交互本身就是一种通信。在系统比较小的时候，可能对象间的通信不是很多、对象也比较少，我们可以直接硬编码到各个对象的方法中。但是当系统规模变大，对象的量变引起系统复杂度的急剧增加，对象间的通信也变得越来越复杂，这时候我们就要提供一个专门处理对象间交互和通信的类，这个中介者就是Mediator模式。Mediator模式提供将对象间的交互和通讯封装在一个类中，各个对象间的通信不必显势去声明和引用，大大降低了系统的复杂性能（了解一个对象总比深入熟悉n个对象要好）。另外Mediator模式还带来了系统对象间的松耦合，这些将在讨论中详细给出。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>     Mediator模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/Mediator.png" alt="Mediator Pattern"></p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>   Mediator模式实现不是很困难，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Mediator">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Mediator&gt; tree &#x2F;F    </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Colleage.h</span><br><span class="line">│      Mediator.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Colleage.cpp</span><br><span class="line">        main.cpp</span><br><span class="line">        Mediator.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Mediator&gt;</span><br></pre></td></tr></table></figure><p>Colleage.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Colleage.h</span><br><span class="line"></span><br><span class="line">#ifndef _COLLEAGE_H_</span><br><span class="line">#define _COLLEAGE_H_</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Mediator;</span><br><span class="line"></span><br><span class="line">class Colleage &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Colleage(&#x2F;* args *&#x2F;);</span><br><span class="line">  Colleage(Mediator* mdt);</span><br><span class="line">  Mediator* _mdt;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Colleage();</span><br><span class="line">  virtual void Aciton() &#x3D; 0;</span><br><span class="line">  virtual void SetState(const string&amp; sdt) &#x3D; 0;</span><br><span class="line">  virtual string GetState() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteColleageA : public Colleage &#123;</span><br><span class="line"> private:</span><br><span class="line">  string _sdt;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteColleageA(&#x2F;* args *&#x2F;);</span><br><span class="line">  ConcreteColleageA(Mediator* mdt);</span><br><span class="line">  ~ConcreteColleageA();</span><br><span class="line">  void Aciton();</span><br><span class="line">  void SetState(const string&amp; sdt);</span><br><span class="line">  string GetState();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteColleageB : public Colleage &#123;</span><br><span class="line"> private:</span><br><span class="line">  string _sdt;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteColleageB(&#x2F;* args *&#x2F;);</span><br><span class="line">  ConcreteColleageB(Mediator* mdt);</span><br><span class="line">  ~ConcreteColleageB();</span><br><span class="line">  void Aciton();</span><br><span class="line">  void SetState(const string&amp; sdt);</span><br><span class="line">  string GetState();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_COLLEAGE_H_</span><br></pre></td></tr></table></figure><p>Mediator.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Mediator.h</span><br><span class="line"></span><br><span class="line">#ifndef _MEDIATOR_H_</span><br><span class="line">#define _MEDIATOR_H_</span><br><span class="line"></span><br><span class="line">class Colleage;</span><br><span class="line"></span><br><span class="line">class Mediator &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Mediator(&#x2F;* args *&#x2F;);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Mediator();</span><br><span class="line">  virtual void DoActionFromAtoB() &#x3D; 0;</span><br><span class="line">  virtual void DoActionFromBtoA() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteMediator:public Mediator</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Colleage* _clgA;</span><br><span class="line">    Colleage* _clgB;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    ConcreteMediator(&#x2F;* args *&#x2F;);</span><br><span class="line">    ConcreteMediator(Colleage*clgA,Colleage* clgB);</span><br><span class="line">    ~ConcreteMediator();</span><br><span class="line">    void SetConcreteColleageA(Colleage*clgA);</span><br><span class="line">    void SetConcreteColleageB(Colleage*clgB);</span><br><span class="line">    Colleage* GetConcreteColleageA();</span><br><span class="line">    Colleage* GetConcreteColleageB();</span><br><span class="line">    void IntroColleage(Colleage*clgA,Colleage* clgB);</span><br><span class="line">    void DoActionFromAtoB();</span><br><span class="line">    void DoActionFromBtoA();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_MEDIATOR_H</span><br></pre></td></tr></table></figure><p>Colleage.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Colleage.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Colleage.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Mediator.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Colleage::Colleage(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Colleage::~Colleage() &#123;&#125;</span><br><span class="line">Colleage::Colleage(Mediator* mdt) &#123; this-&gt;_mdt &#x3D; mdt; &#125;</span><br><span class="line"></span><br><span class="line">ConcreteColleageA::ConcreteColleageA(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteColleageA::~ConcreteColleageA() &#123;&#125;</span><br><span class="line">ConcreteColleageA::ConcreteColleageA(Mediator* mdt) : Colleage(mdt) &#123;&#125;</span><br><span class="line">string ConcreteColleageA::GetState() &#123; return _sdt; &#125;</span><br><span class="line">void ConcreteColleageA::SetState(const string&amp; sdt)&#123;_sdt &#x3D; sdt;&#125;</span><br><span class="line">void ConcreteColleageA::Aciton()&#123;</span><br><span class="line">    _mdt-&gt;DoActionFromAtoB();</span><br><span class="line">    cout&lt;&lt;&quot;State of ConcreteColleageB:&quot;&lt;&lt;&quot;&quot;&lt;&lt;this-&gt;GetState()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteColleageB::ConcreteColleageB(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteColleageB::~ConcreteColleageB() &#123;&#125;</span><br><span class="line">ConcreteColleageB::ConcreteColleageB(Mediator* mdt) : Colleage(mdt) &#123;&#125;</span><br><span class="line">string ConcreteColleageB::GetState() &#123; return _sdt; &#125;</span><br><span class="line">void ConcreteColleageB::SetState(const string&amp; sdt)&#123;_sdt &#x3D; sdt;&#125;</span><br><span class="line">void ConcreteColleageB::Aciton()&#123;</span><br><span class="line">    _mdt-&gt;DoActionFromBtoA();</span><br><span class="line">    cout&lt;&lt;&quot;State of ConcreteColleageB:&quot;&lt;&lt;&quot;&quot;&lt;&lt;this-&gt;GetState()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mediator.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Mediator.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Mediator.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Colleage.h&quot;</span><br><span class="line"></span><br><span class="line">Mediator::Mediator(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Mediator::~Mediator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteMediator::ConcreteMediator(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteMediator::~ConcreteMediator() &#123;&#125;</span><br><span class="line">ConcreteMediator::ConcreteMediator(Colleage* clgA,Colleage* clgB)&#123;</span><br><span class="line">    this-&gt;_clgA &#x3D; clgA;</span><br><span class="line">    this-&gt;_clgB &#x3D; clgB;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteMediator::DoActionFromAtoB()&#123; _clgB-&gt;SetState(_clgA-&gt;GetState()); &#125;</span><br><span class="line">void ConcreteMediator::SetConcreteColleageA(Colleage* clgA)&#123;</span><br><span class="line">    this-&gt;_clgA &#x3D; clgA;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteMediator::SetConcreteColleageB(Colleage* clgB)&#123;</span><br><span class="line">    this-&gt;_clgB &#x3D; clgB;</span><br><span class="line">&#125;</span><br><span class="line">Colleage* ConcreteMediator::GetConcreteColleageA()&#123;</span><br><span class="line">    return _clgA;</span><br><span class="line">&#125;</span><br><span class="line">Colleage* ConcreteMediator::GetConcreteColleageB()&#123;</span><br><span class="line">    return _clgB;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteMediator::IntroColleage(Colleage*clgA,Colleage* clgB)&#123;</span><br><span class="line">    this-&gt;_clgA &#x3D; clgA;</span><br><span class="line">    this-&gt;_clgB &#x3D; clgB;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteMediator::DoActionFromBtoA()&#123;</span><br><span class="line">    _clgA-&gt;SetState(_clgB-&gt;GetState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Colleage.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Mediator.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  ConcreteMediator* m &#x3D; new ConcreteMediator();</span><br><span class="line">  ConcreteColleageA* c1 &#x3D; new ConcreteColleageA(m);</span><br><span class="line">  ConcreteColleageB* c2 &#x3D; new ConcreteColleageB(m);</span><br><span class="line">  m-&gt;IntroColleage(c1, c2);</span><br><span class="line">  c1-&gt;SetState(&quot;old&quot;);</span><br><span class="line">  c2-&gt;SetState(&quot;old&quot;);</span><br><span class="line">  c1-&gt;Aciton();</span><br><span class="line">  c2-&gt;Aciton();</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  c1-&gt;SetState(&quot;new&quot;);</span><br><span class="line">  c1-&gt;Aciton();</span><br><span class="line">  c2-&gt;Aciton();</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  c2-&gt;SetState(&quot;old&quot;);</span><br><span class="line">  c2-&gt;Aciton();</span><br><span class="line">  c1-&gt;Aciton();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>    Mediator模式的实现关键就是将对象<code>Colleague</code>之间的通信封装到一个类种单独处理，为了模拟Mediator模式的功能，这里给每个<code>Colleague</code>对象一个<code>string</code>型别以记录其状态，并通过状态改变来演示对象之间的交互和通信。这里主要就<code>Mediator</code>的示例运行结果给出分析：</p><ul><li>将<code>ConcreteColleageA</code>对象设置状态“<code>old</code>”，<code>ConcreteColleageB</code>也设置状态“<code>old</code>”；</li><li><code>ConcreteColleageA</code>对象改变状态，并在<code>Action中和ConcreteColleageB</code>对象进行通信，并改变<code>ConcreteColleageB</code>对象的状态为“<code>new</code>”；</li><li><code>ConcreteColleageB</code>对象改变状态，并在<code>Action</code>中和<code>ConcreteColleageA</code>对象进行通信，并改变<code>ConcreteColleageA</code>对象的状态为“<code>new</code>”；<br>   注意到，两个<code>Colleague</code>对象并不知道它交互的对象，并且也不是显示地处理交互过程，这一切都是通过<code>Mediator</code>对象完成的，示例程序运行的结果也正是证明了这一点。</li></ul><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Mediator\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Mediator\src&gt; .\a.exe</span><br><span class="line">State of ConcreteColleageB:old</span><br><span class="line">State of ConcreteColleageB:old</span><br><span class="line"></span><br><span class="line">State of ConcreteColleageB:new</span><br><span class="line">State of ConcreteColleageB:new</span><br><span class="line"></span><br><span class="line">State of ConcreteColleageB:old</span><br><span class="line">State of ConcreteColleageB:old</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Mediator\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   Mediator模式是一种很有用并且很常用的模式，它通过将对象间的通信封装到一个类中，将多对多的通信转化为一对多的通信，降低了系统的复杂性。<code>Mediator</code>还获得系统解耦的特性，通过<code>Mediator</code>，各个<code>Colleague</code>就不必维护各自通信的对象和通信协议，降低了系统的耦合性，<code>Mediator</code>和各个<code>Colleague</code>就可以相互独立地修改了。</p><p>     Mediator模式还有一个很显著额特点就是将控制集中，集中的优点就是便于管理，也正式符合了OO设计中的每个类的职责要单一和集中的原则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Memento 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/</id>
    <published>2021-02-08T02:50:56.000Z</published>
    <updated>2021-02-13T09:39:50.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="memento-模式简介"><a class="markdownIt-Anchor" href="#memento-模式简介"></a> Memento 模式简介：</h2><p>   备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。比如Windows里的<code>ctri + z</code>。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>   没有人想犯错误，但是没有人能够不犯错误。犯了错误一般只能改过，却很难改正（恢复）。世界上没有后悔药，但是我们在进行软件系统的设计时候是要给用户后悔的权利（实际上可能也是用户要求的权利：）），我们对一些关键性的操作肯定需要提供诸如撤销（Undo）的操作。那这个后悔药就是Memento模式提供的。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   Memento模式的关键就是要在不破坏封装行的前提下，捕获并保存一个类的内部状态，这样就可以利用该保存的状态实施恢复操作。为了达到这个目标，可以在后面的实现中看到我们采取了一定语言支持的技术。Memento模式的典型结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/Memento.png" alt="Memento Pattern"><br>图 1:Memento 模式结构示意图</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>   Memento模式的实现很简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Memento">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Memento&gt; tree &#x2F;F     </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Memento.h</span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        main.cpp</span><br><span class="line">        Memento.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Memento&gt;</span><br></pre></td></tr></table></figure><p>Memento.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Memento.h</span><br><span class="line"></span><br><span class="line">#ifndef _MEMENTO_H_</span><br><span class="line">#define _MEMENTO_H_</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Memento;</span><br><span class="line"></span><br><span class="line">class Originator &#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef string State;</span><br><span class="line">  Originator();</span><br><span class="line">  Originator(const State&amp; sdt);</span><br><span class="line">  ~Originator();</span><br><span class="line">  Memento* CreateMemento();</span><br><span class="line">  void SetMemento(Memento* men);</span><br><span class="line">  void RestoreToMemento(Memento* mt);</span><br><span class="line">  State GetState();</span><br><span class="line">  void SetState(const State&amp; sdt);</span><br><span class="line">  void PrintState();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  State _sdt;</span><br><span class="line">  Memento* _mt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Memento &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;&#x2F;这是最关键的地方,将 Originator 为friend 类,可以访问内部</span><br><span class="line">  &#x2F;&#x2F;信息,但是其他类不能访问</span><br><span class="line">  friend class Originator;</span><br><span class="line">  typedef string State;</span><br><span class="line">  Memento(&#x2F;* args *&#x2F;);</span><br><span class="line">  Memento(const State&amp; sdt);</span><br><span class="line">  ~Memento();</span><br><span class="line">  void SetState(const State&amp; sdt);</span><br><span class="line">  State GetState();</span><br><span class="line">  State _sdt;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_MEMENTO_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Memento.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Memento.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Memento.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string State;</span><br><span class="line"></span><br><span class="line">Originator::Originator(&#x2F;* args *&#x2F;) &#123;</span><br><span class="line">  _sdt &#x3D; &quot;&quot;;</span><br><span class="line">  _mt &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Originator::Originator(const State&amp; sdt) &#123;</span><br><span class="line">  _sdt &#x3D; sdt;</span><br><span class="line">  _mt &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Originator::~Originator() &#123;&#125;</span><br><span class="line">Memento* Originator::CreateMemento() &#123; return new Memento(_sdt); &#125;</span><br><span class="line">State Originator::GetState() &#123; return _sdt; &#125;</span><br><span class="line">void Originator::SetState(const State&amp; sdt) &#123; _sdt &#x3D; sdt; &#125;</span><br><span class="line">void Originator::PrintState() &#123; cout &lt;&lt; this-&gt;_sdt &lt;&lt; &quot;.....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void Originator::SetMemento(Memento* men) &#123;&#125;</span><br><span class="line">void Originator::RestoreToMemento(Memento* mt) &#123; this-&gt;_sdt &#x3D; mt-&gt;GetState(); &#125;</span><br><span class="line"></span><br><span class="line">Memento::Memento(const State&amp; sdt) &#123; _sdt &#x3D; sdt; &#125;</span><br><span class="line">State Memento::GetState() &#123; return _sdt; &#125;</span><br><span class="line">void Memento::SetState(const State&amp; sdt) &#123; _sdt &#x3D; sdt; &#125;</span><br><span class="line">Memento::~Memento() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Memento.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Originator* o &#x3D; new Originator();</span><br><span class="line">  o-&gt;SetState(&quot;old&quot;);  &#x2F;&#x2F;备忘前状态</span><br><span class="line">  o-&gt;PrintState();</span><br><span class="line">  Memento* m &#x3D; o-&gt;CreateMemento();  &#x2F;&#x2F;将状态备忘</span><br><span class="line">  o-&gt;SetState(&quot;new&quot;);               &#x2F;&#x2F;修改状态</span><br><span class="line">  o-&gt;PrintState();</span><br><span class="line">  o-&gt;RestoreToMemento(m);  &#x2F;&#x2F;恢复修改前状态</span><br><span class="line">  o-&gt;PrintState();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>    Memento模式的关键就是<code>friend class Originator</code>;我们可以看到，<code>Memento</code>的接口都声明为<code>private</code>，而将<code>Originator</code>声明为<code>Memento</code>的友元类。我们将<code>Originator</code>的状态保存在<code>Memento</code>类中，而将<code>Memento</code>接口<code>private</code>起来，也就达到了封装的功效。在<code>Originator</code>类中我们提供了方法让用户后悔：<code>RestoreToMemento</code>(<code>Memento* mt</code>)；我们可以通过这个接口让用户后悔。在测试程序中，我们演示了这一点：<code>Originator</code>的状态由<code>old</code>变为<code>new</code>最后又回到了<code>old</code>。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Memento\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Memento\src&gt; .\a.exe </span><br><span class="line">old.....</span><br><span class="line">new.....</span><br><span class="line">old.....</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Memento\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>    在Command模式中，Memento模式经常被用来维护可以撤销（Undo）操作的状态。这一点将在Command模式具体说明。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Observer 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/</id>
    <published>2021-02-07T11:55:57.000Z</published>
    <updated>2021-02-13T09:39:33.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="observer-模式简介"><a class="markdownIt-Anchor" href="#observer-模式简介"></a> Observer 模式简介：</h2><p>   当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。<br>   比如西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>    Observer模式应该可以说是应用最多、影响最广的模式之一，因为Observer的一个实例Model/View/Control（MVC）结构在系统开发架构设计中有着很重要的地位和意义，MVC实现了业务逻辑和表示层的解耦。个人也认为Observer模式是软件开发过程中必须要掌握和使用的模式之一。在Java阵容中，Struts则提供和MFC中Doc/View结构类似的实现MVC的框架。另外Java语言本身就提供了Observer模式的实现接口，这将在讨论中给出。</p><p>   当然，MVC只是Observer模式的一个实例。Observer模式要解决的问题为：建立一个一（<code>Subject</code>）对多（<code>Observer</code>）的依赖关系，并且做到当“一”变化的时候，依赖这个“一”的多也能够同步改变。最常见的一个例子就是：对同一组数据进行统计分析时候，我们希望能够提供多种形式的表示（例如以表格进行统计显示、柱状图统计显示、百分比统计显示等）。这些表示都依赖于同一组数据，我们当然需要当数据改变的时候，所有的统计的显示都能够同时改变。Observer模式就是解决了这一个问题。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>     Observer 模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/Observer.png" alt="Observer Pattern"><br>图 1:Observer 模式结构示意图 1</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>     Observer模式的实现有些特点，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Observer">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Observer&gt; tree &#x2F;F    </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Observer.h</span><br><span class="line">│      Subject.h</span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        main.cpp</span><br><span class="line">        Observer.cpp</span><br><span class="line">        Subject.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Observer&gt;</span><br></pre></td></tr></table></figure><p>Subject.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Subject.h</span><br><span class="line"></span><br><span class="line">#ifndef _SUBJECT_H_</span><br><span class="line">#define _SUBJECT_H_</span><br><span class="line"></span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string State;</span><br><span class="line"></span><br><span class="line">class Observer;</span><br><span class="line"></span><br><span class="line">class Subject &#123;</span><br><span class="line"> private:</span><br><span class="line">  list&lt;Observer*&gt;* _obvs;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Subject(&#x2F;* args *&#x2F;);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Subject();</span><br><span class="line">  virtual void Attach(Observer* obv);</span><br><span class="line">  virtual void Detach(Observer* obv);</span><br><span class="line">  virtual void Notify();</span><br><span class="line">  virtual void SetState(const State&amp; st) &#x3D; 0;</span><br><span class="line">  virtual State GetState() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteSubject : public Subject &#123;</span><br><span class="line"> private:</span><br><span class="line">  State _st;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteSubject(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~ConcreteSubject();</span><br><span class="line">  State GetState();</span><br><span class="line">  void SetState(const State&amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_SUBJECT_H_</span><br></pre></td></tr></table></figure><p>Observer.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Observer.h</span><br><span class="line"></span><br><span class="line">#ifndef _OBSERVER_H_</span><br><span class="line">#define _OBSERVER_H_</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;Subject.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string State;</span><br><span class="line"></span><br><span class="line">class Observer &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Observer(&#x2F;* args *&#x2F;);</span><br><span class="line">  State _st;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual ~Observer();</span><br><span class="line">  virtual void Update(Subject* sub) &#x3D; 0;</span><br><span class="line">  virtual void PrintInfo() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteObserverA :public Observer &#123;</span><br><span class="line"> private:</span><br><span class="line">  Subject* _sub;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteObserverA(Subject* sub);</span><br><span class="line">  virtual ~ConcreteObserverA();</span><br><span class="line">  virtual Subject* GetSubject();</span><br><span class="line">  &#x2F;&#x2F;传入 Subject 作为参数,这样可以让一个View 属于多个的 Subject。</span><br><span class="line">  void Update(Subject* sub);</span><br><span class="line">  void PrintInfo();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteObserverB :public Observer &#123;</span><br><span class="line"> private:</span><br><span class="line">  Subject* _sub;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteObserverB(Subject* sub);</span><br><span class="line">  virtual ~ConcreteObserverB();</span><br><span class="line">  virtual Subject* GetSubject();</span><br><span class="line">  &#x2F;&#x2F;传入 Subject 作为参数,这样可以让一个View 属于多个的 Subject。</span><br><span class="line">  void Update(Subject* sub);</span><br><span class="line">  void PrintInfo();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_OBSERVER_H_</span><br></pre></td></tr></table></figure><p>Subject.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Subject.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Subject.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Observer.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string state;</span><br><span class="line"></span><br><span class="line">Subject::Subject(&#x2F;* args *&#x2F;) &#123;</span><br><span class="line">  &#x2F;&#x2F;在模板的使用之前一定要 new,创建</span><br><span class="line">  _obvs &#x3D; new list&lt;Observer*&gt;;</span><br><span class="line">&#125;</span><br><span class="line">Subject::~Subject() &#123;&#125;</span><br><span class="line">void Subject::Attach(Observer* obv) &#123; _obvs-&gt;push_front(obv); &#125;</span><br><span class="line">void Subject::Detach(Observer* obv) &#123;</span><br><span class="line">  if (obv !&#x3D; NULL) _obvs-&gt;remove(obv);</span><br><span class="line">&#125;</span><br><span class="line">void Subject::Notify() &#123;</span><br><span class="line">  list&lt;Observer*&gt;::iterator it;</span><br><span class="line">  it &#x3D; _obvs-&gt;begin();</span><br><span class="line">  for (; it !&#x3D; _obvs-&gt;end(); it++) &#123;</span><br><span class="line">    &#x2F;&#x2F;关于模板和 iterator 的用法</span><br><span class="line">    (*it)-&gt;Update(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteSubject::ConcreteSubject(&#x2F;* args *&#x2F;) &#123; _st &#x3D; &#39;\0&#39;; &#125;</span><br><span class="line">ConcreteSubject::~ConcreteSubject() &#123;&#125;</span><br><span class="line">State ConcreteSubject::GetState() &#123; return _st; &#125;</span><br><span class="line">void ConcreteSubject::SetState(const State&amp; st) &#123; _st &#x3D; st; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Observer.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Observer.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Observer.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Subject.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Observer::Observer(&#x2F;* args *&#x2F;) &#123; _st &#x3D; &#39;\0&#39;; &#125;</span><br><span class="line">Observer::~Observer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteObserverA::ConcreteObserverA(Subject* sub) &#123;</span><br><span class="line">  _sub &#x3D; sub;</span><br><span class="line">  _sub-&gt;Attach(this);</span><br><span class="line">&#125;</span><br><span class="line">ConcreteObserverA::~ConcreteObserverA() &#123;</span><br><span class="line">  _sub-&gt;Detach(this);</span><br><span class="line">  if (_sub !&#x3D; 0) delete _sub;</span><br><span class="line">&#125;</span><br><span class="line">Subject* ConcreteObserverA::GetSubject() &#123; return _sub; &#125;</span><br><span class="line">void ConcreteObserverA::PrintInfo() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;ConcreteObserverA observer....&quot; &lt;&lt; _sub-&gt;GetState() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteObserverA::Update(Subject* sub) &#123;</span><br><span class="line">  _st &#x3D; sub-&gt;GetState();</span><br><span class="line">  PrintInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteObserverB::ConcreteObserverB(Subject* sub) &#123;</span><br><span class="line">  _sub &#x3D; sub;</span><br><span class="line">  _sub-&gt;Attach(this);</span><br><span class="line">&#125;</span><br><span class="line">ConcreteObserverB::~ConcreteObserverB() &#123;</span><br><span class="line">  _sub-&gt;Detach(this);</span><br><span class="line">  if (_sub !&#x3D; 0) delete _sub;</span><br><span class="line">&#125;</span><br><span class="line">Subject* ConcreteObserverB::GetSubject() &#123; return _sub; &#125;</span><br><span class="line">void ConcreteObserverB::PrintInfo() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;ConcreteObserverB observer....&quot; &lt;&lt; _sub-&gt;GetState() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteObserverB::Update(Subject* sub) &#123;</span><br><span class="line">  _st &#x3D; sub-&gt;GetState();</span><br><span class="line">  PrintInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Observer.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Subject.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  ConcreteSubject* sub &#x3D; new ConcreteSubject();</span><br><span class="line">  Observer* o1 &#x3D; new ConcreteObserverA(sub);</span><br><span class="line">  Observer* o2 &#x3D; new ConcreteObserverB(sub);</span><br><span class="line">  sub-&gt;SetState(&quot;old&quot;);</span><br><span class="line">  sub-&gt;Notify();</span><br><span class="line">  sub-&gt;SetState(&quot;new&quot;);  &#x2F;&#x2F; 也可以由 Observer 调用</span><br><span class="line">  sub-&gt;Notify();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>  在Observer模式的实现中，<code>Subject</code>维护一个<code>list</code>作为存储其所有观察者的容器。每当调用<code>Notify</code>操作就遍历<code>list</code>中的<code>Observer</code>对象，并广播通知改变状态（调用<code>Observer</code>的<code>Update</code>操作）。目标的状态<code>state</code>可以由<code>Subject</code>自己改变（示例），也可以由<code>Observer</code>的某个操作引起<code>state</code>的改变（可调用<code>Subject</code>的<code>SetState</code>操作）。<code>Notify</code>操作可以由<code>Subject</code>目标主动广播（示例），也可以由<code>Observer</code>观察者来调用（因为<code>Observer</code>维护一个指向Subject的指针）。<br>  运行示例程序，可以看到当<code>Subject</code>处于状态“<code>old</code>”时候，依赖于它的两个观察者都显示“<code>old</code>”，当目标状态改变为“<code>new</code>”的时候，依赖于它的两个观察者也都改变为“<code>new</code>”。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Observer\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Observer\src&gt; .\a.exe</span><br><span class="line">ConcreteObserverB observer....old</span><br><span class="line">ConcreteObserverA observer....old</span><br><span class="line">ConcreteObserverB observer....new</span><br><span class="line">ConcreteObserverA observer....new</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Observer\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>  Observer是影响极为深远的模式之一，也是在大型系统开发过程中要用到的模式之一。除了MFC、Struts提供了MVC的实现框架，在Java语言中还提供了专门的接口实现Observer模式：通过专门的类Observable及Observer接口来实现MVC编程模式，其UML图可以表示为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/MVC.png" alt="Observer MVC"><br>图 2: Java中实现MVC的UML图</p><p>  这里的<code>Observer</code>就是观察者，<code>Observable</code>则充当目标<code>Subject</code>的角色。<br>     Observer模式也称为发布－订阅（publish-subscribe），目标就是通知的发布者，观察者则是通知的订阅者（接受通知）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>State 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/</id>
    <published>2021-02-07T08:01:37.000Z</published>
    <updated>2021-02-13T09:39:10.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="state-模式简介"><a class="markdownIt-Anchor" href="#state-模式简介"></a> State 模式简介：</h2><p>  在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。<br>  在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 <code>context</code> 对象。比如打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>  每个人、事物在不同的状态下会有不同表现（动作），而一个状态又会在不同的表现下转移到下一个不同的状态（State）。最简单的一个生活中的例子就是：地铁入口处，如果你放入正确的地铁票，门就会打开让你通过。在出口处也是验票，如果正确你就可以ok，否则就不让你通过，如果你动作野蛮，或许会有报警（Alarm）。<br>  有限状态自动机（FSM）也是一个典型的状态不同，对输入有不同的响应（状态转移）。通常我们在实现这类系统会使用到很多的<code>Switch/Case</code>语句，<code>Case</code>某种状态，发生什么动作，<code>Case</code>另外一种状态，则发生另外一种状态。但是这种实现方式至少有以下两个问题：</p><ul><li>当状态数目不是很多的时候，<code>Switch/Case</code> 可能可以搞定。但是当状态数目很多的时候（实际系统中也正是如此），维护一大组的1Switch/Case1 语句将是一件异常困难并且容易出错的事情。</li><li>状态逻辑和动作实现没有分离。在很多的系统实现中，动作的实现代码直接写在状态的逻辑当中。这带来的后果就是系统的扩展性和维护得不到保证。</li></ul><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   State模式就是被用来解决上面列出的两个问题的，在State模式中我们将状态逻辑和动作实现进行分离。当一个操作中要维护大量的<code>case</code>分支语句，并且这些分支依赖于对象的状态。State模式将每一个分支都封装到独立的类中。State模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/State.png" alt="State Pattern"><br>图 1:State 模式结构示意图 1</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>   State模式实现上还是有些特点，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/State">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\State&gt; tree &#x2F;F</span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Context.h</span><br><span class="line">│      State.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Context.cpp</span><br><span class="line">        main.cpp</span><br><span class="line">        State.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\State&gt;</span><br></pre></td></tr></table></figure><p>Context.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context.h</span><br><span class="line"></span><br><span class="line">#ifndef _CONTEXT_H_</span><br><span class="line">#define _CONTEXT_H_</span><br><span class="line"></span><br><span class="line">class State;</span><br><span class="line"></span><br><span class="line">class Context &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;&#x2F;表明在 State 类中可以访问 Context 类的 private 字段</span><br><span class="line">  friend class State;</span><br><span class="line">  bool ChangeState(State* state);</span><br><span class="line">  State* _state;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  Context(&#x2F;* args *&#x2F;);</span><br><span class="line">  Context(State* state);</span><br><span class="line">  ~Context();</span><br><span class="line"></span><br><span class="line">  void OprationInterface();</span><br><span class="line">  void OperationChangState();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_CONTEXT_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>State.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; State.h</span><br><span class="line"></span><br><span class="line">#ifndef _STATE_H_</span><br><span class="line">#define _STATE_H_</span><br><span class="line"></span><br><span class="line">class Context;  &#x2F;&#x2F;前置声明</span><br><span class="line"></span><br><span class="line">class State &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  bool ChangeState(Context* con, State* st);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  State(&#x2F;* args *&#x2F;);</span><br><span class="line">  virtual ~State();</span><br><span class="line">  virtual void OperationInterface(Context*) &#x3D; 0;</span><br><span class="line">  virtual void OperationChangeState(Context*) &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStateA:public State</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    ConcreteStateA(&#x2F;* args *&#x2F;);</span><br><span class="line">    virtual ~ConcreteStateA();</span><br><span class="line">    virtual void OperationInterface(Context*);</span><br><span class="line">    virtual void OperationChangeState(Context*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStateB:public State</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    ConcreteStateB(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~ConcreteStateB();</span><br><span class="line">    virtual void OperationInterface(Context*);</span><br><span class="line">    virtual void OperationChangeState(Context*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_STATE_H_</span><br></pre></td></tr></table></figure><p>Context.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;State.h&quot;</span><br><span class="line"></span><br><span class="line">Context::Context(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Context::Context(State* state) &#123; this-&gt;_state &#x3D; state; &#125;</span><br><span class="line">Context::~Context() &#123; delete _state; &#125;</span><br><span class="line">void Context::OprationInterface() &#123; _state-&gt;OperationChangeState(this); &#125;</span><br><span class="line">bool Context::ChangeState(State* state) &#123;</span><br><span class="line">  this-&gt;_state &#x3D; state;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">void Context::OperationChangState() &#123; _state-&gt;OperationChangeState(this); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>State.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; State.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;State.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">State::State(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">State::~State() &#123;&#125;</span><br><span class="line">void State::OperationInterface(Context* con) &#123; printf(&quot;State::.. \n&quot;); &#125;</span><br><span class="line">bool State::ChangeState(Context* con, State* st) &#123;</span><br><span class="line">  con-&gt;ChangeState(st);</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">void State::OperationChangeState(Context* con) &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteStateA::ConcreteStateA(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteStateA::~ConcreteStateA() &#123;&#125;</span><br><span class="line">void ConcreteStateA::OperationInterface(Context* con) &#123;</span><br><span class="line">  printf(&quot;ConcreteStateA::OperationInterface... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteStateA::OperationChangeState(Context* con) &#123;</span><br><span class="line">  OperationInterface(con);</span><br><span class="line">  this-&gt;ChangeState(con, new ConcreteStateB());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteStateB::ConcreteStateB(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteStateB::~ConcreteStateB() &#123;&#125;</span><br><span class="line">void ConcreteStateB::OperationInterface(Context* con) &#123;</span><br><span class="line">  printf(&quot;ConcreteStateB::OperationInterface... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void ConcreteStateB::OperationChangeState(Context* con) &#123;</span><br><span class="line">  OperationInterface(con);</span><br><span class="line">  this-&gt;ChangeState(con, new ConcreteStateA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;State.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line">    State* st &#x3D; new ConcreteStateA();</span><br><span class="line">    Context* con &#x3D; new Context(st);</span><br><span class="line">    con-&gt;OprationInterface();</span><br><span class="line">    con-&gt;OprationInterface();</span><br><span class="line">    con-&gt;OprationInterface();</span><br><span class="line"></span><br><span class="line">    if (con !&#x3D; NULL) delete con;</span><br><span class="line">    if (st !&#x3D; NULL) st &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>   State模式在实现中，有两个关键点：</p><ul><li>将<code>State</code>声明为<code>Context</code>的友元类（<code>friend class</code>），其作用是让State模式访问<code>Context</code>的<code>protected</code>接口<code>ChangeSate（）</code>。</li><li><code>State</code>及其子类中的操作都将<code>Context*</code>传入作为参数，其主要目的是<code>State</code>类可以通过这个指针调用<code>Context</code>中的方法（在本示例代码中没有体现）。这也是<code>State</code>模式和<code>Strategy</code>模式的最大区别所在。<br>   运行了示例代码后可以获得以下的结果：连续3次调用了<code>Context</code>的<code>OprationInterface（）</code>因为每次调用后状态都会改变（<code>A</code>－<code>B</code>－<code>A</code>），因此该动作随着<code>Context</code>的状态的转变而获得了不同的结果。</li></ul><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\State\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\State\src&gt; .\a.exe</span><br><span class="line">ConcreteStateA::OperationInterface...</span><br><span class="line">ConcreteStateB::OperationInterface...</span><br><span class="line">ConcreteStateA::OperationInterface...</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\State\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   State模式的应用也非常广泛，从最高层逻辑用户接口GUI到最底层的通讯协议（例如GoF在《设计模式》中就利用State模式模拟实现一个TCP连接的类。）都有其用武之地。</p><p>   State模式和<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy模式</a>又很大程度上的相似：它们都有一个<code>Context</code>类，都是通过委托（组合）给一个具有多个派生类的多态基类实现<code>Context</code>的算法逻辑。两者最大的差别就是State模式中派生类持有指向<code>Context</code>对象的引用，并通过这个引用调用<code>Context</code>中的方法，但在Strategy模式中就没有这种情况。因此可以说一个State实例同样是Strategy模式的一个实例，反之却不成立。实际上State模式和Strategy模式的区别还在于它们所关注的点不尽相同：State模式主要是要适应对象对于状态改变时的不同处理策略的实现，而Strategy则主要是具体算法和实现接口的解耦（coupling），Strategy模式中并没有状态的概念（虽然很多时候有可以被看作是状态的概念），并且更加不关心状态的改变了。</p><p>   State模式很好地实现了对象的状态逻辑和动作实现的分离，状态逻辑分布在State的派生类中实现，而动作实现则可以放在<code>Context</code>类中实现（这也是为什么State派生类需要拥有一个指向<code>Context</code>的指针）。这使得两者的变化相互独立，改变State的状态逻辑可以很容易复用<code>Context</code>的动作，也可以在不影响<code>State</code>派生类的前提下创建<code>Context</code>的子类来更改或替换动作实现。</p><p>   State模式问题主要是逻辑分散化，状态逻辑分布到了很多的State的子类中，很难看到整个的状态逻辑图，这也带来了代码的维护问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Strategy 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/</id>
    <published>2021-02-07T06:46:35.000Z</published>
    <updated>2021-02-13T09:39:00.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="strategy-模式简介"><a class="markdownIt-Anchor" href="#strategy-模式简介"></a> Strategy 模式简介：</h2><p>  在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>  在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 <code>context</code> 对象。策略对象改变 <code>context</code> 对象的执行算法。<br>  比如旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h2><p>  Strategy模式和<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template模式</a>要解决的问题是相同（类似）的，都是为了给业务逻辑（算法）具体实现和抽象接口之间的解耦。Strategy模式将逻辑（算法）封装到一个类（<code>Context</code>）里面，通过组合的方式将具体算法的实现在组合对象中实现，再通过委托的方式将抽象接口的实现委托给组合对象实现。<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State模式</a>也有类似的功能，他们之间的区别将在讨论中给出。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>Strategy 模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/Strategy.png" alt="Strategy Pattern"><br>图 1:Strategy 模式结构示意图 1</p><p>  这里的关键就是将算法的逻辑抽象接口（<code>DoAction</code>）封装到一个类中（<code>Context</code>），再通过委托的方式将具体的算法实现委托给具体的<code>Strategy</code>类来实现（<code>ConcreteStrategeA</code> 类）。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例（code）</h3><p>   Strategy模式实现很简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Strategy">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Strategy&gt; tree &#x2F;F    </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Context.h</span><br><span class="line">│      Strategy.h</span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Context.cpp</span><br><span class="line">        main.cpp</span><br><span class="line">        Strategy.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Strategy&gt;</span><br></pre></td></tr></table></figure><p>Context.h：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Context.h</span><br><span class="line"></span><br><span class="line">#ifndef _CONTEXT_H_</span><br><span class="line">#define _CONTEXT_H_</span><br><span class="line"></span><br><span class="line">class Strategy;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这个类是 Strategy 模式的关键,也是 Strategy</span><br><span class="line"> * 模式和 Template 模式的根本区别所在。</span><br><span class="line"> * </span><br><span class="line"> * Strategy 通过“组合”(委托)方式实现算法</span><br><span class="line"> * (实现)的异构,而 Template 模式则采取的</span><br><span class="line"> * 是继承的方式</span><br><span class="line"> * </span><br><span class="line"> * 这两个模式的区别也是继承和组合两种实</span><br><span class="line"> * 现接口重用的方式的区别</span><br><span class="line"> * </span><br><span class="line"> * *&#x2F;</span><br><span class="line"></span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Strategy* _stg;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Context(Strategy* stg);</span><br><span class="line">    ~Context();</span><br><span class="line">    void DoAction();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_CONTEXT_H_</span><br></pre></td></tr></table></figure><p>Strategy.h：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Strategy.h</span><br><span class="line"></span><br><span class="line">#ifndef _STRATEGY_H_</span><br><span class="line">#define _STRATEGY_H_</span><br><span class="line"></span><br><span class="line">class Strategy &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"> public:</span><br><span class="line">  Strategy(&#x2F;* args *&#x2F;);</span><br><span class="line">  virtual ~Strategy();</span><br><span class="line">  virtual void AlgrithmInterface() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStrategyA : public Strategy &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"> public:</span><br><span class="line">  ConcreteStrategyA(&#x2F;* args *&#x2F;);</span><br><span class="line">  virtual ~ConcreteStrategyA();</span><br><span class="line">  void AlgrithmInterface();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStrategyB : public Strategy &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"> public:</span><br><span class="line">  ConcreteStrategyB(&#x2F;* args *&#x2F;);</span><br><span class="line">  virtual ~ConcreteStrategyB();</span><br><span class="line">  void AlgrithmInterface();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_STRATEGY_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Context.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Context.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Strategy.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Context::Context(Strategy* stg)</span><br><span class="line">&#123;</span><br><span class="line">    _stg &#x3D; stg;</span><br><span class="line">&#125;</span><br><span class="line">Context::~Context()</span><br><span class="line">&#123;</span><br><span class="line">    if (!_stg) delete _stg;</span><br><span class="line">&#125;</span><br><span class="line">void Context::DoAction()&#123;</span><br><span class="line">    _stg-&gt;AlgrithmInterface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Strategy.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Strategy.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Strategy.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Strategy::Strategy(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Strategy::~Strategy() &#123; printf(&quot;~Strategy.... \n&quot;); &#125;</span><br><span class="line">void Strategy::AlgrithmInterface() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteStrategyA::ConcreteStrategyA(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteStrategyA::~ConcreteStrategyA() &#123; printf(&quot;~ConcreteStrategyA..... \n&quot;); &#125;</span><br><span class="line">void ConcreteStrategyA::AlgrithmInterface() &#123;</span><br><span class="line">  printf(&quot;test ConcreteStrategyA......AlgrithmInterface \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteStrategyB::ConcreteStrategyB(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteStrategyB::~ConcreteStrategyB() &#123; printf(&quot;~ConcreteStrategyB..... \n&quot;); &#125;</span><br><span class="line">void ConcreteStrategyB::AlgrithmInterface() &#123;</span><br><span class="line">  printf(&quot;test ConcreteStrategyB......AlgrithmInterface \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Context.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Strategy.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Strategy* ps;</span><br><span class="line">  ps &#x3D; new ConcreteStrategyA();</span><br><span class="line">  Context* pc &#x3D; new Context(ps);</span><br><span class="line">  pc-&gt;DoAction();</span><br><span class="line">  if (NULL !&#x3D; pc) delete pc;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>  Strategy模式的代码很直观，关键是将算法的逻辑封装到一个类中。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Strategy\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Strategy\src&gt; .\a.exe</span><br><span class="line">test ConcreteStrategyA......AlgrithmInterface</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Strategy\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>  可以看到Strategy模式和Template模式解决了类似的问题，也正如在Template模式中分析的，Strategy模式和Template模式实际是实现一个抽象接口的两种方式：继承和组合之间的区别。要实现一个抽象接口，继承是一种方式：我们将抽象接口声明在基类中，将具体的实现放在具体子类中。组合（委托）是另外一种方式：我们将接口的实现放在被组合对象中，将抽象接口放在组合类中。这两种方式各有优缺点，先列出来：</p><ul><li>继承：<ul><li>优点<ul><li>易于修改和扩展那些被复用的实现。</li></ul></li><li>缺点<ul><li>破坏了封装性，继承中父类的实现细节暴露给子类了；</li><li>“白盒”复用，原因在1）中；</li><li>当父类的实现更改时，其所有子类将不得不随之改变</li><li>从父类继承而来的实现在运行期间不能改变（编译期间就已经确定了）。</li></ul></li></ul></li><li>组合<ul><li>优点<ul><li>“黑盒”复用，因为被包含对象的内部细节对外是不可见的；</li><li>封装性好，原因为1）；</li><li>实现和抽象的依赖性很小（组合对象和被组合对象之间的依赖性小）；</li><li>可以在运行期间动态定义实现（通过一个指向相同类型的指针，典型的是抽象基类的指针）。</li></ul></li><li>缺点<ul><li>系统中对象过多。</li></ul></li></ul></li></ul><p>   从上面对比中我们可以看出，组合相比继承可以取得更好的效果，因此在面向对象的设计中的有一条很重要的原则就是：优先使用（对象）组合，而非（类）继承（<code>FavorComposition Over Inheritance</code>）。<br>   实际上，继承是一种强制性很强的方式，因此也使得基类和具体子类之间的耦合性很强。例如在Template模式中在<code>ConcreteClass1</code>中定义的原语操作别的类是不能够直接复用（除非你继承自<code>AbstractClass</code>，具体分析请参看<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template模式文档</a>）。而组合（委托）的方式则有很小的耦合性，实现（具体实现）和接口（抽象接口）之间的依赖性很小，例如在本实现中，<code>ConcreteStrategyA</code>的具体实现操作很容易被别的类复用，例如我们要定义另一个<code>Context</code>类<code>AnotherContext</code>，只要组合一个指向<code>Strategy</code>的指针就可以很容易地复用<code>ConcreteStrategyA</code>的实现了。<br>   我们在<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge模式</a>的问题和Bridge模式的分析中，正是说明了继承和组合之间的区别。请参看相应模式解析。<br>   另外Strategy模式很<a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State模式</a>也有相似之处，但是State模式注重的对象在不同的状态下不同的操作。两者之间的区别就是State模式中具体实现类中有一个指向Context的引用，而Strategy模式则没有。具体分析请参看相应的State模式分析中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Template 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/</id>
    <published>2021-02-07T06:04:58.000Z</published>
    <updated>2021-02-13T09:38:50.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="template-模式简介"><a class="markdownIt-Anchor" href="#template-模式简介"></a> Template 模式简介：</h2><p>  在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。<br>  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>  比如在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>  在面向对象系统的分析与设计过程中经常会遇到这样一种情况：对于某一个业务逻辑（算法实现）在不同的对象中有不同的细节实现，但是逻辑（算法）的框架（或通用的应用算法）是相同的。Template提供了这种情况的一个实现框架。<br>  Template模式是采用继承的方式实现这一点：将逻辑（算法）框架放在抽象基类中，并定义好细节的接口，子类中实现细节。<sup>【注释1】</sup></p><blockquote><p>【注释1】：Strategy模式解决的是和Template模式类似的问题，但是Strategy模式是将逻辑（算法）封装到一个类中，并采取组合（委托）的方式解决这个问题。</p></blockquote><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   上述问题可以采取两种模式来解决，一是Template模式，二是Strategy模式。本文当给出的是Template模式。一个通用的Template模式的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/template.png" alt="Template Pattern"><br>图 1:Template 模式结构示意图 1</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例(code)</h3><p>   Template模式的实现很简单，这里为了方便初学者的学习和参考，将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/behavioralPattern/Template">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Template&gt; tree &#x2F;F    </span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Template.h</span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        main.cpp</span><br><span class="line">        Template.cpp</span><br><span class="line">        </span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Template&gt;</span><br></pre></td></tr></table></figure><p>Template.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Template.h</span><br><span class="line">#ifndef _TEMPLATE_H_</span><br><span class="line">#define _TEMPLATE_H_</span><br><span class="line"></span><br><span class="line">class AbstractClass &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  virtual void PrimitiveOperation1() &#x3D; 0;</span><br><span class="line">  virtual void PrimitiveOperation2() &#x3D; 0;</span><br><span class="line">  AbstractClass();</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  void TemplateMethod();</span><br><span class="line">  virtual ~AbstractClass();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteClass1 : public AbstractClass &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  void PrimitiveOperation1();</span><br><span class="line">  void PrimitiveOperation2();</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteClass1(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~ConcreteClass1();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteClass2 : public AbstractClass &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  void PrimitiveOperation1();</span><br><span class="line">  void PrimitiveOperation2();</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteClass2(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~ConcreteClass2();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~ TEMPLATE H</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Template.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Template.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Template.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">AbstractClass::AbstractClass(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">AbstractClass::~AbstractClass() &#123;&#125;</span><br><span class="line">void AbstractClass::TemplateMethod() &#123;</span><br><span class="line">  this-&gt;PrimitiveOperation1();</span><br><span class="line">  this-&gt;PrimitiveOperation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteClass1::ConcreteClass1(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteClass1::~ConcreteClass1() &#123;&#125;</span><br><span class="line">void ConcreteClass1::PrimitiveOperation1() &#123; printf(&quot;ConcreteClass1...PrimitiveOperation1 \n&quot;); &#125;</span><br><span class="line">void ConcreteClass1::PrimitiveOperation2() &#123; printf(&quot;ConcreteClass1...PrimitiveOperation2 \n&quot;); &#125;</span><br><span class="line"></span><br><span class="line">ConcreteClass2::ConcreteClass2(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteClass2::~ConcreteClass2() &#123;&#125;</span><br><span class="line">void ConcreteClass2::PrimitiveOperation1() &#123; printf(&quot;ConcreteClass2...PrimitiveOperation1 \n&quot;); &#125;</span><br><span class="line">void ConcreteClass2::PrimitiveOperation2() &#123; printf(&quot;ConcreteClass2...PrimitiveOperation2 \n&quot;); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Template.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  AbstractClass* p1 &#x3D; new ConcreteClass1();</span><br><span class="line">  AbstractClass* p2 &#x3D; new ConcreteClass2();</span><br><span class="line">  p1-&gt;TemplateMethod();</span><br><span class="line">  p2-&gt;TemplateMethod();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>  由于Template模式的实现代码很简单，因此解释是多余的。其关键是将通用算法（逻辑）封装起来，而将算法细节让子类实现（多态）。<br>  唯一注意的是我们将原语操作（细节算法）定义未保护（Protected）成员，只供模板方法调用（子类可以）。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Template\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Template\src&gt; .\a.exe</span><br><span class="line">ConcreteClass1...PrimitiveOperation1</span><br><span class="line">ConcreteClass1...PrimitiveOperation2</span><br><span class="line">ConcreteClass2...PrimitiveOperation1</span><br><span class="line">ConcreteClass2...PrimitiveOperation2</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\behavioralPattern\Template\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>  Template模式是很简单模式，但是也应用很广的模式。如上面的分析和实现中阐明的Template是采用继承的方式实现算法的异构，其关键点就是将通用算法封装在抽象基类中，并将不同的算法细节放到子类中实现。<br>    Template模式获得一种反向控制结构效果，这也是面向对象系统的分析和设计中一个原则DIP（依赖倒置：Dependency Inversion Principles）。其含义就是父类调用子类的操作（高层模块调用低层模块的操作），低层模块实现高层模块声明的接口。这样控制权在父类（高层模块），低层模块反而要依赖高层模块。<br>  继承的强制性约束关系也让Template模式有不足的地方，我们可以看到对于<code>ConcreteClass</code>类中的实现的原语方法<code>Primitive1()</code>，是不能被别的类复用。假设我们要创建一个<code>AbstractClass</code>的变体<code>AnotherAbstractClass</code>，并且两者只是通用算法不一样，其原语操作想复用<code>AbstractClass</code>的子类的实现。但是这是不可能实现的，因为<code>ConcreteClass</code>继承自<code>AbstractClass</code>，也就继承了<code>AbstractClass</code>的通用算法，<code>AnotherAbstractClass</code>是复用不了<code>ConcreteClass</code>的实现，因为后者不是继承自前者。<br>    Template模式暴露的问题也正是继承所固有的问题，Strategy模式则通过组合（委托）来达到和Template模式类似的效果，其代价就是空间和时间上的代价，关于Strategy模式的详细讨论请参考Strategy模式解析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Proxy 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/</id>
    <published>2021-02-06T11:03:20.000Z</published>
    <updated>2021-02-13T09:38:29.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="proxy-模式简介"><a class="markdownIt-Anchor" href="#proxy-模式简介"></a> Proxy 模式简介：</h2><p>  在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>  在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。<br>  主要解决在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br>   比如猪八戒去找高翠兰，结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>  至少在以下集中情况下可以用 Proxy模式解决问题：</p><ul><li>创建开销大的对象时候，比如显示一幅大的图片，我们将这个创建的过程交给代理去完成，GoF称之为虚代理（ Virtual Proxy）；</li><li>为网络上的对象创建一个局部的本地代理，比如要操作一个网络上的一个对象（网络性能不好的时候，问题尤其突出），我们将这个操纵的过程交给一个代理去完成，GoF称之为远程代理（ Remote Proxy）</li><li>对对象进行控制访问的时候，比如在Jive论坛中不同权限的用户（如管理员、普通用户等）将获得不同层次的操作权限，我们将这个工作交给一个代理去完成，GoF称之为保护代理（ Protection Proxy）</li><li>智能指针（ Smart pointer），关于这个方面的内容，建议参看 Andrew Koenig的《C++沉思录》中的第5章。</li></ul><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>   <code>Proxy</code> 模式典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/image-14.png" alt="Proxy Pattern"><br>图 1:Proxy 模式结构示意图 1</p><p>   实际上，Proxy 模式的想法非常简单。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例-code"><a class="markdownIt-Anchor" href="#完整代码示例-code"></a> 完整代码示例（ code）</h3><p>   Proxy 模式完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。<br>   源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Proxy">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Proxy&gt; tree &#x2F;F</span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Proxy.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        main.cpp</span><br><span class="line">        Proxy.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Proxy&gt;</span><br></pre></td></tr></table></figure><p>Proxy.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Proxy.h</span><br><span class="line"></span><br><span class="line">#ifndef _PROXY_H_</span><br><span class="line">#define _PROXY_H_</span><br><span class="line"></span><br><span class="line">class Subject &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Subject();</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  virtual void Request() &#x3D; 0;</span><br><span class="line">  virtual ~Subject();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteSubject : public Subject &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"> public:</span><br><span class="line">  ConcreteSubject(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~ConcreteSubject();</span><br><span class="line">  void Request();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Proxy &#123;</span><br><span class="line"> private:</span><br><span class="line">  Subject* _sub;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  Proxy(&#x2F;* args *&#x2F;);</span><br><span class="line">  Proxy(Subject* sub);</span><br><span class="line">  ~Proxy();</span><br><span class="line">  void Request();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_PROXY_H_</span><br></pre></td></tr></table></figure><p>Proxy.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Proxy.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Proxy.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Subject::Subject(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Subject::~Subject() &#123;&#125;</span><br><span class="line"></span><br><span class="line">ConcreteSubject::ConcreteSubject(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">ConcreteSubject::~ConcreteSubject() &#123;&#125;</span><br><span class="line">void ConcreteSubject::Request() &#123; printf(&quot;ConcreteSubject......request.... \n&quot;); &#125;</span><br><span class="line"></span><br><span class="line">Proxy::Proxy(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Proxy::Proxy(Subject* sub) &#123; _sub &#x3D; sub; &#125;</span><br><span class="line">Proxy::~Proxy() &#123; delete _sub; &#125;</span><br><span class="line">void Proxy::Request() &#123;</span><br><span class="line">  printf(&quot;Proxy request.... \n&quot;);</span><br><span class="line">  _sub-&gt;Request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Proxy.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Subject* sub &#x3D; new ConcreteSubject();</span><br><span class="line">  Proxy* p &#x3D; new Proxy(sub);</span><br><span class="line">  p-&gt;Request();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>  Proxy 模式的实现很简单，这里不做多余解释。<br>  可以看到，示例代码运行后，<code>p</code> 的 <code>Request</code> 请求实际上是交给了 <code>sub</code> 来实际执行。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Proxy\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Proxy\src&gt; .\a.exe</span><br><span class="line">Proxy request....</span><br><span class="line">ConcreteSubject......request....</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Proxy\src&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>  Proxy 模式最大的好处就是实现了逻辑和实现的彻底解耦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Facade 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/</id>
    <published>2021-02-06T09:22:51.000Z</published>
    <updated>2021-02-13T09:37:53.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="facade-模式简介"><a class="markdownIt-Anchor" href="#facade-模式简介"></a> Facade 模式简介：</h2><p>  外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>  这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br>  比如去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>  举一个生活中的小例子，大凡开过学或者毕过业的都会体会到这样一种郁闷：你要去 <code>n</code> 个地方办理 <code>n</code> 个手续（现在大学合并后就更加麻烦，因为可能那 <code>n</code> 个地方都隔的比较远）。但是实际上我们需要的就是一个最后一道手续的证明而已，对于前面的手续是怎么办的、到什么地方去办理我们都不感兴趣。<br>  实际上在软件系统开发中也经常回会遇到这样的情况，可能你实现了一些接口（模块），而这些接口（模块）都分布在几个类中（比如 <code>A</code> 和 <code>B</code>、<code>C</code>、<code>D</code>）：<code>A</code> 中实现了一些接口，<code>B</code> 中实现一些接口（或者 A 代表一个独立模块，<code>B</code>、<code>C</code>、<code>D</code> 代表另一些独立模块）。然后你的客户程序员（使用你设计的开发人员）只有很少的要知道你的不同接口到底是在那个类中实现的，绝大多数只是想简单的组合你的 <code>A</code>－<code>D</code> 的类的接口，他并不想知道这些接口在哪里实现的。这里的客户程序员就是上面生活中想办理手续的郁闷的人！在现实生活中我们可能可以很快想到找一个人代理所有的事情就可以解决你的问题（你只要维护和他的简单的一个接口而已了！），在软件系统设计开发中我们可以通过一个叫做 <code>Façade</code> 的模式来解决上面的问题。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>  我们通过 <code>Facade</code> 模式解决上面的问题，其典型的结构图为：</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/Facade.png" alt="Facade Pattern"><br>图 1:Facade 模式结构示意图 1</p><p>   <code>Façade</code> 模式的想法、思路和实现都非常简单，但是其思想却是非常有意义的。并且 <code>Façade</code> 设计模式在实际的开发设计中也是应用最广、最多的模式之一。</p><p>  一个简单的例子就是，在 <code>Visual CMCS</code> 项目里，在 <code>Visual CMCS</code> 中我们将允许用户独立访问我们的编译子系统（词法、语法、语义、代码生成模块），这些都是通过特定的类实现的，我们通过使用 <code>Façade</code> 模式给用户提供一个高层的接口，供用户在不想了解编译器实现的情况下去使用或重用我们的设计和实现。我们将提供一个 <code>Compile</code> 类作为 <code>Façade</code> 对象。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例-code"><a class="markdownIt-Anchor" href="#完整代码示例-code"></a> 完整代码示例（ code）</h3><p>  Flyweight 模式完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。<br>   <strong>源码gitee地址</strong>：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Facade">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Facade&gt; tree &#x2F;F</span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Facade.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Facade.cpp</span><br><span class="line">        main.cpp</span><br></pre></td></tr></table></figure><p>Facade.h：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Facade.h</span><br><span class="line"></span><br><span class="line">#ifndef _FACADE_H_</span><br><span class="line">#define _FACADE_H_</span><br><span class="line"></span><br><span class="line">class Subsystem1</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    Subsystem1(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~Subsystem1();</span><br><span class="line">    void Operation();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Subsystem2</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    Subsystem2(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~Subsystem2();</span><br><span class="line">    void Operation();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Subsystem1* _subs1;</span><br><span class="line">    Subsystem2* _subs2;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Facade(&#x2F;* args *&#x2F;);</span><br><span class="line">    ~Facade();</span><br><span class="line">    void OperationWrapper();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F;~_FACADE_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Facade.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Facade.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Facade.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Subsystem1::Subsystem1(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Subsystem1::~Subsystem1() &#123;&#125;</span><br><span class="line">void Subsystem1::Operation() &#123; printf(&quot;Subsystem1 operation.. \n&quot;); &#125;</span><br><span class="line"></span><br><span class="line">Subsystem2::Subsystem2(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">Subsystem2::~Subsystem2() &#123;&#125;</span><br><span class="line">void Subsystem2::Operation() &#123; printf(&quot;Subsystem2 operation.. \n&quot;); &#125;</span><br><span class="line"></span><br><span class="line">Facade::Facade(&#x2F;* args *&#x2F;) &#123;</span><br><span class="line">    this-&gt;_subs1 &#x3D; new Subsystem1();</span><br><span class="line">    this-&gt;_subs2 &#x3D; new Subsystem2();</span><br><span class="line">&#125;</span><br><span class="line">Facade::~Facade() &#123;</span><br><span class="line">    delete _subs1;</span><br><span class="line">    delete _subs2;</span><br><span class="line">&#125;</span><br><span class="line">void Facade::OperationWrapper()&#123;</span><br><span class="line">    this-&gt;_subs1-&gt;Operation();</span><br><span class="line">    this-&gt;_subs2-&gt;Operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Facade.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  Facade* f &#x3D; new Facade();</span><br><span class="line">  f-&gt;OperationWrapper();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>   <code>Facade</code> 模式的实现很简单，多余的解释完全是没有必要。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Facade\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Facade\src&gt; .\a.exe</span><br><span class="line">Subsystem1 operation..</span><br><span class="line">Subsystem2 operation..</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Facade\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>   <code>Facade</code> 模式在高层提供了一个统一的接口，解耦了系统。设计模式中还有另一种模式 <code>Mediator</code> 也和 <code>Facade</code> 有类似的地方。但是 <code>Mediator</code> 主要目的是对象间的访问的解耦（通讯时候的协议），具体请参见 <code>Mediator</code> 文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Flyweight 模式 -GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/</id>
    <published>2020-12-14T06:11:09.000Z</published>
    <updated>2021-02-13T09:37:37.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="flyweight-模式简介"><a class="markdownIt-Anchor" href="#flyweight-模式简介"></a> Flyweight 模式简介：</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。<br>使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>  在面向对象系统的设计何实现中，创建对象是最为常见的操作。这里面就有一个问题：<br>  如果一个应用程序使用了太多的对象， 就会造成很大的存储开销。 特别是对于大量轻量级（细粒度）的对象，比如在文档编辑器的设计过程中，我们如果为没有字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。例如一个字母“<code>a</code>”在文档中出现了<code>100000</code> 次， 而实际上我们可以让这一万个字母“<code>a</code>” 共享一个对象， 当然因为在不同的位置，可能字母“ a” 有不同的显示效果（例如字体和大小等设置不同）， 在这种情况我们可以为将对象的状态分为“外部状态”和“ 内部状态”， 将可以被共享（不会变化）的状态作为内部状态存储在对象中， 而外部对象（例如上面提到的字体、 大小等） 我们可以在适当的时候将外部对象最为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>上面解决问题的方式被称作 Flyweight 模式解决上面的问题，其典型的结构图为：<br><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/Flyweight.png" alt="Flyweight"><br>图 1:Flyweight Pattern 结构图</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例-code"><a class="markdownIt-Anchor" href="#完整代码示例-code"></a> 完整代码示例（ code）</h3><p>Flyweight 模式完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。<br>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Flyweight">点击这里</a></p><p>代码目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Flyweight&gt; tree &#x2F;F</span><br><span class="line">卷 Windows 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 F0C5-AFA6</span><br><span class="line">C:.</span><br><span class="line">├─include</span><br><span class="line">│      Flyweight.h</span><br><span class="line">│      FlyweightFactory.h</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        a.out</span><br><span class="line">        Flyweight.cpp</span><br><span class="line">        FlyweightFactory.cpp</span><br><span class="line">        main.cpp</span><br><span class="line"></span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Flyweight&gt;</span><br></pre></td></tr></table></figure><p>Flyweight.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Flyweight.h</span><br><span class="line"></span><br><span class="line">#ifndef _FLYWEIGHT_H_</span><br><span class="line">#define _FLYWEIGHT_H_</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Flyweight &#123;</span><br><span class="line"> private:</span><br><span class="line">  string _intrinsicState;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  Flyweight(string intrinsicState);</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  Flyweight(&#x2F;* args *&#x2F;);</span><br><span class="line">  virtual ~Flyweight();</span><br><span class="line"></span><br><span class="line">  virtual void Operation(const string&amp; extrinsicState);</span><br><span class="line">  string GetIntrinsicState();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteFlyweight : public Flyweight &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;* data *&#x2F;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  ConcreteFlyweight(string intrinsicState);</span><br><span class="line">  ~ConcreteFlyweight();</span><br><span class="line">  virtual void Operation(const string&amp; extrinsicState);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_FLYWEIGHT_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>FlyweightFactory.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FlyweightFactory.h</span><br><span class="line"></span><br><span class="line">#ifndef _FLYWEIGHTFACTORY_H_</span><br><span class="line">#define _FLYWEIGHTFACTORY_H_</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;Flyweight.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class FlyweightFactory &#123;</span><br><span class="line"> private:</span><br><span class="line">  vector&lt;Flyweight*&gt; _fly;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  FlyweightFactory(&#x2F;* args *&#x2F;);</span><br><span class="line">  ~FlyweightFactory();</span><br><span class="line"></span><br><span class="line">  Flyweight* GetFlyweight(const string&amp; key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;&#x2F;~_FLYWEIGHTFACTORY_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Flyweight.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Flyweight.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Flyweight.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Flyweight::Flyweight(string intrinsicState) &#123; this-&gt;_intrinsicState &#x3D; intrinsicState; &#125;</span><br><span class="line">Flyweight::~Flyweight() &#123;&#125;</span><br><span class="line">void Flyweight::Operation(const string&amp; extrinsicState) &#123;&#125;</span><br><span class="line">string Flyweight::GetIntrinsicState() &#123; return this-&gt;_intrinsicState; &#125;</span><br><span class="line"></span><br><span class="line">ConcreteFlyweight::ConcreteFlyweight(string intrinsicState) : Flyweight(intrinsicState) &#123;</span><br><span class="line">  cout&lt;&lt;&quot;ConcreteFlyweight Build.....&quot;&lt;&lt;intrinsicState&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">ConcreteFlyweight::~ConcreteFlyweight() &#123;&#125;</span><br><span class="line">void ConcreteFlyweight::Operation(const string&amp; extrinsicState) &#123;</span><br><span class="line">  cout &lt;&lt; &quot;ConcreteFlyweight: 内 蕴[&quot; &lt;&lt; this-&gt;GetIntrinsicState() &lt;&lt; &quot;] 外 蕴[&quot; &lt;&lt; extrinsicState</span><br><span class="line">       &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlyweightFactory.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FlyweightFactory.cpp</span><br><span class="line"></span><br><span class="line">#include &quot;..&#x2F;include&#x2F;FlyweightFactory.h&quot;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">FlyweightFactory::FlyweightFactory(&#x2F;* args *&#x2F;) &#123;&#125;</span><br><span class="line">FlyweightFactory::~FlyweightFactory() &#123;&#125;</span><br><span class="line">Flyweight* FlyweightFactory::GetFlyweight(const string&amp; key) &#123;</span><br><span class="line">  vector&lt;Flyweight*&gt;::iterator it &#x3D; _fly.begin();</span><br><span class="line"></span><br><span class="line">  for (; it !&#x3D; _fly.end(); it++) &#123;</span><br><span class="line">    &#x2F;&#x2F;找到了,就一起用,^_^</span><br><span class="line">    if ((*it)-&gt;GetIntrinsicState() &#x3D;&#x3D; key) &#123;</span><br><span class="line">      printf(&quot;already created by users... \n&quot;);</span><br><span class="line"></span><br><span class="line">      return *it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Flyweight* fn &#x3D; new ConcreteFlyweight(key);</span><br><span class="line">  _fly.push_back(fn);</span><br><span class="line"></span><br><span class="line">  return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;Flyweight.h&quot;</span><br><span class="line">#include &quot;..&#x2F;include&#x2F;FlyweightFactory.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  FlyweightFactory* fc &#x3D; new FlyweightFactory();</span><br><span class="line">  Flyweight* fw1 &#x3D; fc-&gt;GetFlyweight(&quot;hello&quot;);</span><br><span class="line">  Flyweight* fw2 &#x3D; fc-&gt;GetFlyweight(&quot;world!&quot;);</span><br><span class="line">  Flyweight* fw3 &#x3D; fc-&gt;GetFlyweight(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>  <code>Flyweight</code> 模式在实现过程中主要是要为共享对象提供一个存放的“仓库”（对象池），这里是通过 C++ STL 中 <code>Vector</code> 容器， 当然就牵涉到 STL 编程的一些问题（ <code>Iterator</code> 使用等）。<br>  另外应该注意的就是对对象“仓库”（对象池） 的管理策略（查找、 插入等）， 这里是通过直接的顺序遍历实现的，当然我们可以使用其他更加有效的索引策略，例如 Hash 表的管理策略，当时这些细节已经不是 <code>Flyweight</code> 模式本身要处理的了。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Flyweight\src&gt; g++ *.cpp -std&#x3D;c++11</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Flyweight\src&gt; .\a.exe</span><br><span class="line">ConcreteFlyweight Build.....hello</span><br><span class="line">ConcreteFlyweight Build.....world!</span><br><span class="line">already created by users...</span><br><span class="line">PS C:\Users\guopz\Desktop\GiteeBlog\designpatternsbycpipei\structuralPattern\Flyweight\src&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>  我们在 <code>State</code> 模式和 <code>Strategy</code> 模式中会产生很多的对象，因此我们可以通过 <code>Flyweight</code> 模式来解决这个问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Composite 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/</id>
    <published>2020-12-13T04:48:25.000Z</published>
    <updated>2021-02-13T09:37:19.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="composite-模式简介"><a class="markdownIt-Anchor" href="#composite-模式简介"></a> Composite 模式简介：</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>在开发中,我们经常可能要递归构建树状的组合结构,Composite 模式则提供了很好的解决方案。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>Composite 模式的典型结构图为:</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/image-11.png" alt></p><p>图 1:Composite Pattern 结构图</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例(code)</h3><p>Composite 模式的实现起来很简单,这里为了方便初学者的学习和参考,将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Composite">点击这里</a></p><p>代码目录结构：</p><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Composite/src$ tree ../../├── include│   ├── Component.h│   ├── Composite.h│   └── Leaf.h└── src    ├── Component.cpp    ├── Composite.cpp    ├── Leaf.cpp    └── main.cpp2 directories, 7 files</code></pre><p>Component.h：</p><pre><code>// Component.h#ifndef _COMPONENT_H_#define _COMPONENT_H_class Component &#123; private:  /* data */ public:  Component(/* args */);  virtual ~Component();  virtual void Operation() = 0;  virtual void Add(const Component&amp;);  virtual void Remove(const Component&amp;);  virtual Component* GetChild(int);&#125;;#endif //~_COMPONENT_H_</code></pre><p>Component.cpp：</p><pre><code>//Component.cpp#include &quot;../include/Component.h&quot;Component::Component(/* args */) &#123;&#125;Component::~Component() &#123;&#125;void Component::Add(const Component&amp; com) &#123;&#125;Component* Component::GetChild(int index) &#123; return 0; &#125;void Component::Remove(const Component&amp; com)&#123;&#125;</code></pre><p>Composite.h：</p><pre><code>//Composite.h#ifndef _COMPOSITE_H_#define _COMPOSITE_H_#include &quot;Component.h&quot;#include &lt;vector&gt;using namespace std;class Composite:public Component&#123;private:    vector&lt;Component*&gt; comVec;public:    Composite();    ~Composite();    void Operation();    void Add(Component* com);    void Remove(Component* com);    Component* GetChild(int index);&#125;;#endif //~_COMPOSITE_H_</code></pre><p>Composite.cpp：</p><pre><code>// Composite.cpp#include &quot;../include/Composite.h&quot;#include &quot;../include/Component.h&quot;Composite::Composite() &#123; vector&lt;Component*&gt;::iterator itend = comVec.end(); &#125;Composite::~Composite() &#123;&#125;void Composite::Operation() &#123;  vector&lt;Component*&gt;::iterator comIter = comVec.begin();  for (; comIter != comVec.end(); comIter++) &#123;    (*comIter)-&gt;Operation();  &#125;&#125;void Composite::Add(Component* com) &#123; comVec.push_back(com); &#125;void Composite::Remove(Component* com) &#123;    comVec.pop_back();&#125;Component* Composite::GetChild(int index) &#123; return comVec[index]; &#125;</code></pre><p>Leaf.h：</p><pre><code>//Leaf.h#ifndef _LEAF_H_#define _LEAF_H_#include &quot;Component.h&quot;class Leaf:public Component&#123;private:    /* data */public:    Leaf(/* args */);    ~Leaf();    void Operation();&#125;;#endif //~_LEAF_H_</code></pre><p>Leaf.cpp：</p><pre><code>// Leaf.cpp#include &quot;../include/Leaf.h&quot;#include &lt;iostream&gt;using namespace std;Leaf::Leaf(/* args */) &#123;&#125;Leaf::~Leaf() &#123;&#125;void Leaf::Operation() &#123; printf(&quot;Leaf operation..... \n&quot;); &#125;</code></pre><p>main.cpp：</p><pre><code>// main.cpp#include &lt;iostream&gt;#include &quot;../include/Component.h&quot;#include &quot;../include/Composite.h&quot;#include &quot;../include/Leaf.h&quot;using namespace std;int main(int argc, char* argv[]) &#123;  Leaf* l = new Leaf();  l-&gt;Operation();  Composite* com = new Composite();  com-&gt;Add(l);  com-&gt;Operation();  Component* ll = com-&gt;GetChild(0);  ll-&gt;Operation();  return 0;&#125;</code></pre><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>Composite 模式在实现中有一个问题就是要提供对于子节点(<code>Leaf</code>)的管理策略,这里使用的是 <code>STL</code> 中的 <code>vector</code>,可以提供其他的实现方式,如数组、链表、Hash 表等。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> 编译运行结果：</h3><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Composite/src$ g++ *.cpp -std=c++11patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Composite/src$ ./a.out Leaf operation..... Leaf operation..... Leaf operation..... </code></pre><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>Composite 模式通过和 Decorator 模式有着类似的结构图,但是 Composite 模式旨在构造类,而 Decorator 模式重在不生成子类即可给对象添加职责。Decorator 模式重在修饰,而Composite 模式重在表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Decorator 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/</id>
    <published>2020-12-13T04:44:33.000Z</published>
    <updated>2021-02-13T09:36:57.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="decorator-模式简介"><a class="markdownIt-Anchor" href="#decorator-模式简介"></a> Decorator 模式简介：</h2><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>在 OO 设计和开发过程,可能会经常遇到以下的情况:我们需要为一个已经定义好的类添加新的职责(操作),通常的情况我们会给定义一个新类继承自定义好的类,这样会带来一个问题(将在本模式的讨论中给出)。通过继承的方式解决这样的情况还带来了系统的复杂性,因为继承的深度会变得很深。<br>而 Decorator 提供了一种给类增加职责的方法,不是通过继承实现的,而是通过组合。有关这些内容在讨论中进一步阐述。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>Decorator 模式典型的结构图为:</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/image-10.png" alt></p><p>图 1:Decorator Pattern 结构图</p><p>在 结 构 图 中 , ConcreteComponent 和 Decorator 需 要 有 同 样 的 接 口 , 因 此ConcreteComponent 和 Decorator 有着一个共同的父类。这里有人会问,让 Decorator 直接维护一个指向 ConcreteComponent 引用(指针)不就可以达到同样的效果,答案是肯定并且是否定的。肯定的是你可以通过这种方式实现,否定的是你不要用这种方式实现,因为通过这种方式你就只能为这个特定的 ConcreteComponent 提供修饰操作了,当有了一个新的ConcreteComponent 你 又 要 去 新 建 一 个 Decorator 来 实 现 。 但 是 通 过 结 构 图 中 的ConcreteComponent 和 Decorator 有一个公共基类,就可以利用 OO 中多态的思想来实现只要是 Component 型别的对象都可以提供修饰操作的类,这种情况下你就算新建了 100 个Component 型别的类 ConcreteComponent,也都可以由 Decorator 一个类搞定。这也正是Decorator 模式的关键和威力所在了。</p><p>当然如果你只用给 Component 型别类添加一种修饰,则 Decorator 这个基类就不是很必要了。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>实现</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>完整代码示例(code)</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></h3><p>Decorator 模式的实现起来并不是十分困难,这里为了方便初学者的学习和参考,将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Decorator">点击这里</a></p><p>代码目录结构：</p><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Decorator/src$ tree ../../├── include│   └── Decorator.h└── src    ├── Decorator.cpp    └── main.cpp2 directories, 3 files</code></pre><p>Decorator.h：</p><pre><code>// Decorator.h#ifndef _DECORATOR_H_#define _DECORATOR_H_class Component &#123; private:  /* data */ protected:  Component(/* args */); public:  virtual ~Component();  virtual void Operation();&#125;;class ConcreteComponent : public Component &#123; private:  /* data */ public:  ConcreteComponent(/* args */);  ~ConcreteComponent();  void Operation();&#125;;class Decorator : public Component &#123; private:  /* data */ protected:  Component* _com; public:  Decorator(Component* com);  ~Decorator();  void Operation();&#125;;class ConcreteDecorator: public Decorator&#123;private:    /* data */public:    ConcreteDecorator(Component* com);    ~ConcreteDecorator();    void Operation();    void AddedBehavior();&#125;;#endif  //~_DECORATOR_H_</code></pre><p>Decorator.cpp：</p><pre><code>// Decorator.cpp#include &quot;../include/Decorator.h&quot;#include &lt;iostream&gt;Component::Component(/* args */) &#123;&#125;Component::~Component() &#123;&#125;void Component::Operation() &#123;&#125;ConcreteComponent::ConcreteComponent(/* args */) &#123;&#125;ConcreteComponent::~ConcreteComponent() &#123;&#125;void ConcreteComponent::Operation() &#123; printf(&quot;ConcreteComponent operation... \n&quot;); &#125;Decorator::Decorator(Component* com) &#123; this-&gt;_com = com; &#125;Decorator::~Decorator() &#123; delete _com; &#125;void Decorator::Operation() &#123;&#125;ConcreteDecorator::ConcreteDecorator(Component* com):Decorator(com) &#123;&#125;ConcreteDecorator::~ConcreteDecorator() &#123;&#125;void ConcreteDecorator::AddedBehavior()&#123;    printf(&quot;ConcreteDecorator::AddedBehavior... \n&quot;);&#125;void ConcreteDecorator::Operation()&#123;    _com-&gt;Operation();    this-&gt;AddedBehavior();&#125;</code></pre><p>main.cpp：</p><pre><code>// main.cpp#include &lt;iostream&gt;#include &quot;../include/Decorator.h&quot;using namespace std;int main(int argc, char* argv[]) &#123;  Component* com = new ConcreteComponent();  Decorator* dec = new ConcreteDecorator(com);  dec-&gt;Operation();  delete dec;  return 0;&#125;</code></pre><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>Decorator 模 式 很 简 单 ,代 码 本 身 没有 什 么 好 说明 的 。 运 行示 例 代 码 可以 看 到 ,ConcreteDecorator 给 ConcreteComponent 类添加了动作 AddedBehavior。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> <strong><strong><strong>编译运行结果：</strong></strong></strong></h3><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Decorator/src$ g++ *.cpp -std=c++11patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Decorator/src$ ./a.out ConcreteComponent operation... ConcreteDecorator::AddedBehavior... patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Decorator/src$</code></pre><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>Decorator 模式和 Composite 模式有相似的结构图,其区别在 Composite 模式已经详细讨论过了,请参看相应文档。另外 GoF 在《设计模式》中也讨论到 Decorator 和 Proxy 模式有很大程度上的相似,初学设计模式可能实在看不出这之间的一个联系和相似,并且它们在结构图上也很不相似。实际上,在本文档“<strong>模式选择</strong>”中分析到,让 Decorator 直接拥有一个 ConcreteComponent 的引用(指针)也可以达到修饰的功能,大家再把这种方式的结构图画出来,就和 Proxy 很相似了!</p><p>Decorator 模式和 Proxy 模式的相似的地方在于它们都拥有一个指向其他对象的引用(指针),即通过组合的方式来为对象提供更多操作(或者 Decorator 模式)间接性(Proxy 模式)。但是他们的区别是,Proxy 模式会提供使用其作为代理的对象一样接口,使用代理类将其操作都委托给 Proxy 直接进行。这里可以简单理解为组合和委托之间的微妙的区别了。</p><p>Decorator 模式除了采用组合的方式取得了比采用继承方式更好的效果,Decorator 模式还给设计带来一种“即用即付”的方式来添加职责。在 OO 设计和分析经常有这样一种情况:为了多态,通过父类指针指向其具体子类,但是这就带来另外一个问题,当具体子类要添加新的职责,就必须向其父类添加一个这个职责的抽象接口,否则是通过父类指针是调用不到这个方法了。这样处于高层的父类就承载了太多的特征(方法),并且继承自这个父类的所有子类都不可避免继承了父类的这些接口,但是可能这并不是这个具体子类所需要的。而在Decorator 模式提供了一种较好的解决方法,当需要添加一个操作的时候就可 以通过Decorator 模式来解决,你可以一步步添加新的职责。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Adapter 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/</id>
    <published>2020-12-13T04:40:20.000Z</published>
    <updated>2021-02-13T09:36:32.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="adapter-模式简介"><a class="markdownIt-Anchor" href="#adapter-模式简介"></a> Adapter 模式简介：</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>Adapter 模式解决的问题在生活中经常会遇到:比如我们有一个 Team 为外界提供 S 类服务,但是我们 Team 里面没有能够完成此项任务的 member,然后我们得知有 A 可以完成这项服务(他把这项人物重新取了个名字叫 S’,并且他不对外公布他的具体实现)。为了保证我们对外的服务类别的一致性(提供 S 服务),我们有以下两种方式解决这个问题:</p><ol><li>把 B 君直接招安到我们 Team 为我们工作,提供 S 服务的时候让 B 君去办就是了;</li><li>B 君可能在别的地方有工作,并且不准备接受我们的招安,于是我们 Team 可以想这样一种方式解决问题:我们安排 C 君去完成这项任务,并做好工作(Money:))让 A 君工作的时候可以向 B 君请教,因此 C 君就是一个复合体(提供 S 服务,但是是 B 君的继承弟子)。</li></ol><p>实际上在软件系统设计和开发中,这种问题也会经常遇到:我们为了完成某项工作购买了一个第三方的库来加快开发。这就带来了一个问题:我们在应用程序中已经设计好了接口,与这个第三方提供的接口不一致,为了使得这些接口不兼容的类(不能在一起工作)可以在一起工作了,Adapter 模式提供了将一个类(第三方库)的接口转化为客户(购买使用者)希望的接口。</p><p>在上面生活中问题的解决方式也就正好对应了 Adapter 模式的两种类别:类模式和对象模式。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>Adapter 模式典型的结构图为:</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/image-2.png" alt></p><p>图 1:Adapter Pattern(类模式)结构图</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/image-3.png" alt></p><p>图 2:Adapter Pattern(对象模式)结构图</p><p>在 Adapter 模式的结构图中可以看到,类模式的 Adapter 采用继承的方式复用 Adaptee的接口,而在对象模式的 Adapter 中我们则采用组合的方式实现Adaptee 的复用。有关这些具体的实现和分析将在代码说明和讨论中给出。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> 完整代码示例(code)</h3><p>Adapter 模式的实现很简单,这里为了方便初学者的学习和参考,将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Adapter">点击这里</a></p><p>代码目录结构：</p><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Adapter/src$ tree ../../├── include│   ├── Adaptee.h│   ├── Adapter.h│   └── Target.h└── src    ├── Adaptee.cpp    ├── Adapter.cpp    ├── main.cpp    └── Target.cpp2 directories, 7 files</code></pre><p>Adaptee.h：</p><pre><code>//Adaptee.h#ifndef ADAPTEE_H#define ADAPTEE_H#include &lt;iostream&gt;using namespace std;//需要适配的类class Adaptee &#123; public:  Adaptee();  ~Adaptee();  void SpecificRequest();&#125;;#endif  // ADAPTEE_H</code></pre><p>Adaptee.cpp：</p><pre><code>//Adaptee.cpp#include &quot;../include/Adaptee.h&quot;#include &lt;iostream&gt;Adaptee::Adaptee() &#123;&#125;Adaptee::~Adaptee() &#123;&#125;void Adaptee::SpecificRequest() &#123; cout &lt;&lt; &quot;Adaptee::SpecificRequest()&quot; &lt;&lt; endl; &#125;</code></pre><p>Target.h：</p><pre><code>//Target.h#ifndef TARGET_H#define TARGET_H#include &lt;iostream&gt;//目标接口类，客户需要的接口class Target &#123; public:  Target();  virtual ~Target();  virtual void Request();  //定义标准接口&#125;;#endif  // TARGET_H</code></pre><p>Target.cpp：</p><pre><code>//Target.cpp#include &quot;../include/Target.h&quot;#include &lt;iostream&gt;using namespace std;Target::Target() &#123;&#125;Target::~Target() &#123;&#125;void Target::Request() &#123; cout &lt;&lt; &quot;Target::Request()&quot; &lt;&lt; endl; &#125;</code></pre><p>Adapter.h：</p><pre><code>//Adapter.h#ifndef _ADAPTER_H_#define _ADAPTER_H_#include &quot;Target.h&quot;#include &quot;Adaptee.h&quot;//类模式，适配器类，通过public继承获得接口继承的效果，通过private继承获得实现继承的效果class Adapter : public Target, private Adaptee &#123; public:  Adapter();  ~Adapter();  virtual void Request();  //实现Target定义的Request接口&#125;;//对象模式，适配器类，继承Target类，采用组合的方式实现Adaptee的复用class Adapter1 : public Target &#123; public:  Adapter1(Adaptee* adaptee);  Adapter1();  ~Adapter1();  virtual void Request();  //实现Target定义的Request接口 private:  Adaptee* _adaptee;&#125;;#endif</code></pre><p>Adapter.cpp：</p><pre><code>//Adapter.cpp#include &quot;../include/Adapter.h&quot;#include &lt;iostream&gt;//类模式的AdapterAdapter::Adapter() &#123;&#125;Adapter::~Adapter() &#123;&#125;void Adapter::Request() &#123;  cout &lt;&lt; &quot;Adapter::Request()&quot; &lt;&lt; endl;  this-&gt;SpecificRequest();  cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;&#125;//对象模式的AdapterAdapter1::Adapter1() : _adaptee(new Adaptee) &#123;&#125;Adapter1::Adapter1(Adaptee* _adaptee) &#123; this-&gt;_adaptee = _adaptee; &#125;Adapter1::~Adapter1() &#123;&#125;void Adapter1::Request() &#123;  cout &lt;&lt; &quot;Adapter1::Request()&quot; &lt;&lt; endl;  this-&gt;_adaptee-&gt;SpecificRequest();  cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;&#125;</code></pre><p>main.cpp：</p><pre><code>//main.cpp#include &quot;../include/Adapter.h&quot;#include &lt;iostream&gt;int main() &#123;  //类模式Adapter  Target* pTarget = new Adapter();  pTarget-&gt;Request();  //对象模式Adapter1  Adaptee* ade = new Adaptee();  Target* pTarget1 = new Adapter1(ade);  pTarget1-&gt;Request();  //对象模式Adapter2  Target* pTarget2 = new Adapter1();  pTarget2-&gt;Request();  return 0;&#125;</code></pre><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> <strong>代码说明</strong></h3><p>Adapter 模式实现上比较简单,要说明的是在类模式 <code>Adapter</code> 中,我们通过 <code>private</code> 继承<code>Adaptee</code> 获得实现继承的效果,而通过 <code>public</code> 继承 <code>Target</code> 获得接口继承的效果(有关实现继<br>承和接口继承参见讨论部分)。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> <strong>编译运行结果：</strong></h3><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Adapter/src$ g++ *.cpp -std=c++11patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Adapter/src$ ./a.out Adapter::Request()Adaptee::SpecificRequest()----------------------------Adapter1::Request()Adaptee::SpecificRequest()----------------------------Adapter1::Request()Adaptee::SpecificRequest()----------------------------patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Adapter/src$</code></pre><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>在 Adapter 模式的两种模式中,有一个很重要的概念就是接口继承和实现继承的区别和联系。接口继承和实现继承是面向对象领域的两个重要的概念,接口继承指的是通过继承,子类获得了父类的接口,而实现继承指的是通过继承子类获得了父类的实现(并不统共接口)。在 C<ins>中的 <code>public</code> 继承既是接口继承又是实现继承,因为子类在继承了父类后既可以对外提供父类中的接口操作,又可以获得父类的接口实现。当然我们可以通过一定的方式和技术模拟单独的接口继承和实现继承,例如我们可以通过 <code>private</code> 继承获得实现继承的效果(<code>private</code> 继承后,父类中的接口都变为 <code>private</code>,当然只能是实现继承了。),通过纯抽象基类模拟接口继承的效果,但是在 C</ins>中 <code>pure virtual function</code> 也可以提供默认实现,因此这是不纯正的接口继承,但是在 Java 中我们可以 <code>interface</code> 来获得真正的接口继承了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Bridge 模式-GoF 23 种设计模式精解系列-附 C++实现源码</title>
    <link href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/"/>
    <id>https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/</id>
    <published>2020-12-13T04:28:15.000Z</published>
    <updated>2021-02-13T09:36:18.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan University的K_Eckel（frwei@whu.edu.cn）《设计模式精解-GoF 23 种设计模式解析附 C++实现源码》。为了避免重造轮子，本系列博文对源码在ubuntu16.04下做了验证并上传到了<a href="https://gitee.com/PattenKuo/designpatternsbycpipei">gitee</a>，再次感谢。</p><p>如有问题，可邮件联系我(<a href="mailto:guopengzhen@guopengzhen.com">guopengzhen@guopengzhen.com</a>)并共同探讨解决方案。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="创建型模式creating-pattern"><a class="markdownIt-Anchor" href="#创建型模式creating-pattern"></a> 创建型模式(Creating Pattern)</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15645/">Factory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34277/">AbstactFactory 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48635/">Singleton 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42048/">Builder 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16065/">Prototype 模式</a></p><h3 id="结构型模式structrual-pattern"><a class="markdownIt-Anchor" href="#结构型模式structrual-pattern"></a> 结构型模式（Structrual Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/">Bridge 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65216/">Adapter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61255/">Decorator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30230/">Composite 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53984/">Flyweight 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51937/">Facade 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26330/">Proxy 模式</a></p><h3 id="行为型模式behavioral-pattern"><a class="markdownIt-Anchor" href="#行为型模式behavioral-pattern"></a> 行为型模式（Behavioral  Pattern）</h3><p><a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52399/">Template 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63289/">Strategy 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63548/">State 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25006/">Observer 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46123/">Memento 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44726/">Mediator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1841/">Command 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65039/">Visitor 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5352/">Iterator 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32738/">Interpreter 模式</a> | <a href="https://guopengzhen.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61386/">Chain of Responsibility 模式</a></p><h2 id="bridge-模式简介"><a class="markdownIt-Anchor" href="#bridge-模式简介"></a> Bridge 模式简介：</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>总结面向对象实际上就两句话:一是松耦合(Coupling),二是高内(Cohesion)。面向对象系统追求的目标就是尽可能地提高系统模块内部的内聚(Cohesion)、尽可能降低模块间的耦合(Coupling)。然而这也是面向对象设计过程中最为难把握的部分,大家肯定在OO 系统的开发过程中遇到这样的问题:</p><ol><li>客户给了你一个需求,于是使用一个类来实现(<code>A</code>);</li><li>客户需求变化,有两个算法实现功能,于是改变设计,我们通过一个抽象的基类,再定义两个具体类实现两个不同的算法(<code>A1</code> 和 <code>A2</code>);</li><li>客户又告诉我们说对于不同的操作系统,于是再抽象一个层次,作为一个抽象基类<code>A0</code>,在分别为每个操作系统派生具体类(<code>A00</code> 和 <code>A01</code>,其中 <code>A00</code> 表示原来的类 <code>A</code>)实现不同操作系统上的客户需求,这样我们就有了一共 4 个类。</li><li>可能用户的需求又有变化,比如说又有了一种新的算法…</li><li>我们陷入了一个需求变化的郁闷当中,也因此带来了类的迅速膨胀。</li></ol><p>Bridge 模式则正是解决了这类问题。</p><h2 id="模式选择"><a class="markdownIt-Anchor" href="#模式选择"></a> 模式选择</h2><p>Bridge 模式典型的结构图为:</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14587/image-1.png" alt></p><p>图 1:Bridge Pattern 结构图</p><p>在 Bridge 模式的结构图中可以看到,系统被分为两个相对独立的部分,左边是抽象部分,右边是实现部分,这两个部分可以互相独立地进行修改:例如上面问题中的客户需求变化,当用户需求需要从 <code>Abstraction</code> 派生一个具体子类时候,并不需要像上面通过继承方式实现时候需要添加子类 <code>A1</code> 和 <code>A2</code> 了。另外当上面问题中由于算法添加也只用改变右边实现(添加一个具体化子类),而右边不用在变化,也不用添加具体子类了。</p><p>一切都变得 elegant!</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="完整代码示例code"><a class="markdownIt-Anchor" href="#完整代码示例code"></a> <strong><strong><strong>完整代码示例(code)</strong></strong></strong></h3><p>Bridge 模式的实现并不是特别困难,这里为了方便初学者的学习和参考,将给出完整的实现代码(所有代码采用 C++实现,并在 Visual Studio Code，Version: 1.36.1 下测试运行)。</p><p>源码gitee地址：<a href="https://gitee.com/PattenKuo/designpatternsbycpipei/tree/master/structuralPattern/Bridge">点击这里</a></p><p>代码目录结构：</p><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Bridge/src$ tree ../../├── include│   ├── Abstraction.h│   └── AbstractionImp.h└── src    ├── Abstraction.cpp    ├── AbstractionImp.cpp    └── main.cpp2 directories, 5 files</code></pre><p>Abstraction.h：</p><pre><code>// Abstraction.h#ifndef _ABSTRACTION_H_#define _ABSTRACTION_H_class AbstractionImp;class Abstraction &#123; private:  /* data */ protected:  Abstraction(/* args */); public:  virtual ~Abstraction();  virtual void Operation() = 0;&#125;;class RefinedAbstraction: public Abstraction&#123;private:    AbstractionImp* _imp;public:    RefinedAbstraction(AbstractionImp* imp);    ~RefinedAbstraction();    void Operation();&#125;;#endif //~_ABSTRACTION_H_</code></pre><p>AbstractionImp.h：</p><pre><code>// AbstractionImp.h#ifndef _ABSTRACTIONIMP_H_#define _ABSTRACTIONIMP_H_class AbstractionImp &#123; private:  /* data */ protected:  AbstractionImp(/* args */); public:  virtual ~AbstractionImp();  virtual void Operation() = 0;&#125;;class ConcreteAbstractionImpA: public AbstractionImp&#123;private:    /* data */public:    ConcreteAbstractionImpA(/* args */);    ~ConcreteAbstractionImpA();    virtual void Operation();&#125;;class ConcreteAbstractionImpB: public AbstractionImp&#123;private:    /* data */public:    ConcreteAbstractionImpB(/* args */);    ~ConcreteAbstractionImpB();    virtual void Operation();&#125;;#endif //~_ABSTRACTIONIMP_H_</code></pre><p>Abstraction.cpp：</p><pre><code>//Abstraction.cpp#include &quot;../include/Abstraction.h&quot;#include &quot;../include/AbstractionImp.h&quot;#include &lt;iostream&gt;using namespace std;Abstraction::Abstraction(/* args */) &#123;&#125;Abstraction::~Abstraction() &#123;&#125;RefinedAbstraction::RefinedAbstraction(AbstractionImp* imp) &#123;    _imp = imp;&#125;RefinedAbstraction::~RefinedAbstraction() &#123;&#125;void RefinedAbstraction::Operation()&#123;    _imp-&gt;Operation();&#125;</code></pre><p>AbstractionImp.cpp：</p><pre><code>// AbstractionImp.cpp#include &quot;../include/AbstractionImp.h&quot;#include &lt;iostream&gt;using namespace std;AbstractionImp::AbstractionImp(/* args */) &#123;&#125;AbstractionImp::~AbstractionImp() &#123;&#125;void AbstractionImp::Operation()&#123;    printf(&quot;AbstractionImp....imp... \n&quot;);&#125;ConcreteAbstractionImpA::ConcreteAbstractionImpA(/* args */) &#123;&#125;ConcreteAbstractionImpA::~ConcreteAbstractionImpA() &#123;&#125;void ConcreteAbstractionImpA::Operation()&#123;    printf(&quot;ConcreteAbstractionImpA....imp... \n&quot;);&#125;ConcreteAbstractionImpB::ConcreteAbstractionImpB(/* args */) &#123;&#125;ConcreteAbstractionImpB::~ConcreteAbstractionImpB() &#123;&#125;void ConcreteAbstractionImpB::Operation()&#123;    printf(&quot;ConcreteAbstractionImpB....imp... \n&quot;);&#125;</code></pre><p>main.cpp：</p><pre><code>// main.cpp#include &lt;iostream&gt;#include &quot;../include/Abstraction.h&quot;#include &quot;../include/AbstractionImp.h&quot;using namespace std;int main(int argc, char* argv[]) &#123;  AbstractionImp* imp = new ConcreteAbstractionImpA();  Abstraction* abs = new RefinedAbstraction(imp);  abs-&gt;Operation();  return 0;&#125;</code></pre><h3 id="代码说明"><a class="markdownIt-Anchor" href="#代码说明"></a> 代码说明</h3><p>Bridge 模式将抽象和实现分别独立实现,在代码中就是 <code>Abstraction</code> 类和 <code>AbstractionImp</code>类。</p><h3 id="编译运行结果"><a class="markdownIt-Anchor" href="#编译运行结果"></a> <strong>编译运行结果：</strong></h3><pre><code>patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Bridge/src$ g++ *.cpp -std=c++11patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Bridge/src$ ./a.out ConcreteAbstractionImpA....imp... patten@patten-hp:~/workspace/others/cpp/designPatterns/structuralPattern/Bridge/src$</code></pre><h2 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2><p>Bridge 是设计模式中比较复杂和难理解的模式之一,也是 OO 开发与设计中经常会用到的模式之一。使用组合(委托)的方式将抽象和实现彻底地解耦,这样的好处是抽象和实现可以分别独立地变化,系统的耦合性也得到了很好的降低。</p><p>GoF 在说明 Bridge 模式时,在意图中指出 Bridge 模式“将抽象部分与它的实现部分分离,使得它们可以独立地变化”。这句话很简单,但是也很复杂,连 Bruce Eckel 在他的大作《Thinking in Patterns》中说“Bridge 模式是 GoF 所讲述得最不好(Poorly-described)的模式”,个人觉得也正是如此。原因就在于 GoF 的那句话中的“实现”该怎么去理解:“实现”特别是和“抽象”放在一起的时候我们“默认”的理解是“实现”就是“抽象”的具体子类的实现,但是这里 GoF 所谓的“实现”的含义不是指抽象基类的具体子类对抽象基类中虚函数(接口)的实现,是和继承结合在一起的。而这里的“实现”的含义指的是怎么去实现用户的需求,并且指的是通过组合(委托)的方式实现的,因此这里的实现不是指的继承基类、实现基类接口,而是指的是通过对象组合实现用户的需求。理解了这一点也就理解了Bridge 模式,理解了 Bridge 模式,你的设计就会更加 Elegant 了。</p><p>实际上上面使用 Bridge 模式和使用带来问题方式的解决方案的根本区别在于是通过继承还是通过组合的方式去实现一个功能需求。因此面向对象分析和设计中有一个原则就是:<strong><em>Favor Composition Over Inheritance</em></strong>。其原因也正在这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;尊重原创，本系列文本解析部分主要基于Candidate for Master’s Degree School of Computer Wuhan</summary>
      
    
    
    
    <category term="设计模式" scheme="https://guopengzhen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原创拙笔" scheme="https://guopengzhen.com/tags/%E5%8E%9F%E5%88%9B%E6%8B%99%E7%AC%94/"/>
    
    <category term="程序猿的学习笔记" scheme="https://guopengzhen.com/tags/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://guopengzhen.com/tags/C/"/>
    
  </entry>
  
</feed>
